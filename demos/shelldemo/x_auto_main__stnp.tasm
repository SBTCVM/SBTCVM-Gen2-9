#SSTNPL COMPILER v0.3.0
#header
head-rname=auto_main
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "demos/shelldemo/auto_main.stnp
null;0;cmdflg
null;0;validcom
null;0++---;*0++---
null;+++---;*+++---
null;10x0;@0
null;10x1;@1
null;+++--0;*+++--0
#prline
fopwri1;:T
fopwri1;:h
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:a
fopwri1;:\s
fopwri1;:b
fopwri1;:a
fopwri1;:s
fopwri1;:i
fopwri1;:c
fopwri1;:\s
fopwri1;:m
fopwri1;:u
fopwri1;:l
fopwri1;:t
fopwri1;:i
fopwri1;:-
fopwri1;:c
fopwri1;:h
fopwri1;:a
fopwri1;:r
fopwri1;:a
fopwri1;:c
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:-
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:l
fopwri1;:\s
fopwri1;:d
fopwri1;:e
fopwri1;:m
fopwri1;:o
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:t
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:s
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#label
null;;main--label
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:>
#goto (extra code stores away return address.)
setreg1;>goto--jumper-47
s1push1
goto;>cp.getentry--label
null;;goto--jumper-47
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validcom
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--61
null;;tabstrc--adrbuff--61
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--61
null;;tabstrc--outbuff--61
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--61

datawrite1;>tabstrc--recurs-tabbuff--61_1
dataread1;;tabstrc--recurs-tabbuff--61_1
datawrite1;>tabstrc--recurs-tabbuff_read--61_1
dataread1;;tabstrc--recurs-tabbuff_read--61_1

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--61_1
goto;>tabstrc--recurs-checkno--61_1
null;;tabstrc--recurs-checkyes--61_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--61
setreg2;+
add
datawrite1;>tabstrc--adrbuff--61

setreg1;>tabstrc--adrbuff--61

datawrite1;>tabstrc--recurs-tabbuff--61_2
dataread1;;tabstrc--recurs-tabbuff--61_2
datawrite1;>tabstrc--recurs-tabbuff_read--61_2
dataread1;;tabstrc--recurs-tabbuff_read--61_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--61_2
goto;>tabstrc--recurs-checkno--61_2
null;;tabstrc--recurs-checkyes--61_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--61
setreg2;+
add
datawrite1;>tabstrc--adrbuff--61

setreg1;>tabstrc--adrbuff--61

datawrite1;>tabstrc--recurs-tabbuff--61_3
dataread1;;tabstrc--recurs-tabbuff--61_3
datawrite1;>tabstrc--recurs-tabbuff_read--61_3
dataread1;;tabstrc--recurs-tabbuff_read--61_3

setreg2;:l


gotoif;>tabstrc--recurs-checkyes--61_3
goto;>tabstrc--recurs-checkno--61_3
null;;tabstrc--recurs-checkyes--61_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--61
setreg2;+
add
datawrite1;>tabstrc--adrbuff--61

setreg1;>tabstrc--adrbuff--61

datawrite1;>tabstrc--recurs-tabbuff--61_4
dataread1;;tabstrc--recurs-tabbuff--61_4
datawrite1;>tabstrc--recurs-tabbuff_read--61_4
dataread1;;tabstrc--recurs-tabbuff_read--61_4

setreg2;:p


gotoif;>tabstrc--recurs-checkyes--61_4
goto;>tabstrc--recurs-checkno--61_4
null;;tabstrc--recurs-checkyes--61_4
##set flag########
setreg1;>tabstrc--outbuff--61
datawrite1;>tabstrc--recurs-flag--61_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--61_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--61_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--61_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--61_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--61_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--61
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-63
goto;>goto--jumper-63
dataread1;>@1;goto--branch-63
datawrite1;>validcom
null;;goto--jumper-63
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-64
goto;>goto--jumper-64
setreg1;>goto--jumper-64;goto--branch-64
s1push1
goto;>help--label
null;;goto--jumper-64
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--66
null;;tabstrc--adrbuff--66
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--66
null;;tabstrc--outbuff--66
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_1
dataread1;;tabstrc--recurs-tabbuff--66_1
datawrite1;>tabstrc--recurs-tabbuff_read--66_1
dataread1;;tabstrc--recurs-tabbuff_read--66_1

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--66_1
goto;>tabstrc--recurs-checkno--66_1
null;;tabstrc--recurs-checkyes--66_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--66
setreg2;+
add
datawrite1;>tabstrc--adrbuff--66

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_2
dataread1;;tabstrc--recurs-tabbuff--66_2
datawrite1;>tabstrc--recurs-tabbuff_read--66_2
dataread1;;tabstrc--recurs-tabbuff_read--66_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--66_2
goto;>tabstrc--recurs-checkno--66_2
null;;tabstrc--recurs-checkyes--66_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--66
setreg2;+
add
datawrite1;>tabstrc--adrbuff--66

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_3
dataread1;;tabstrc--recurs-tabbuff--66_3
datawrite1;>tabstrc--recurs-tabbuff_read--66_3
dataread1;;tabstrc--recurs-tabbuff_read--66_3

setreg2;:l


gotoif;>tabstrc--recurs-checkyes--66_3
goto;>tabstrc--recurs-checkno--66_3
null;;tabstrc--recurs-checkyes--66_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--66
setreg2;+
add
datawrite1;>tabstrc--adrbuff--66

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_4
dataread1;;tabstrc--recurs-tabbuff--66_4
datawrite1;>tabstrc--recurs-tabbuff_read--66_4
dataread1;;tabstrc--recurs-tabbuff_read--66_4

setreg2;:l


gotoif;>tabstrc--recurs-checkyes--66_4
goto;>tabstrc--recurs-checkno--66_4
null;;tabstrc--recurs-checkyes--66_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--66
setreg2;+
add
datawrite1;>tabstrc--adrbuff--66

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_5
dataread1;;tabstrc--recurs-tabbuff--66_5
datawrite1;>tabstrc--recurs-tabbuff_read--66_5
dataread1;;tabstrc--recurs-tabbuff_read--66_5

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--66_5
goto;>tabstrc--recurs-checkno--66_5
null;;tabstrc--recurs-checkyes--66_5
##set flag########
setreg1;>tabstrc--outbuff--66
datawrite1;>tabstrc--recurs-flag--66_5
setreg1;+
datawrite1;;tabstrc--recurs-flag--66_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--66
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-68
goto;>goto--jumper-68
dataread1;>@1;goto--branch-68
datawrite1;>validcom
null;;goto--jumper-68
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-69
goto;>goto--jumper-69
setreg1;>goto--jumper-69;goto--branch-69
s1push1
goto;>hello--label
null;;goto--jumper-69
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--71
null;;tabstrc--adrbuff--71
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--71
null;;tabstrc--outbuff--71
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--71

datawrite1;>tabstrc--recurs-tabbuff--71_1
dataread1;;tabstrc--recurs-tabbuff--71_1
datawrite1;>tabstrc--recurs-tabbuff_read--71_1
dataread1;;tabstrc--recurs-tabbuff_read--71_1

setreg2;:q


gotoif;>tabstrc--recurs-checkyes--71_1
goto;>tabstrc--recurs-checkno--71_1
null;;tabstrc--recurs-checkyes--71_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--71
setreg2;+
add
datawrite1;>tabstrc--adrbuff--71

setreg1;>tabstrc--adrbuff--71

datawrite1;>tabstrc--recurs-tabbuff--71_2
dataread1;;tabstrc--recurs-tabbuff--71_2
datawrite1;>tabstrc--recurs-tabbuff_read--71_2
dataread1;;tabstrc--recurs-tabbuff_read--71_2

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--71_2
goto;>tabstrc--recurs-checkno--71_2
null;;tabstrc--recurs-checkyes--71_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--71
setreg2;+
add
datawrite1;>tabstrc--adrbuff--71

setreg1;>tabstrc--adrbuff--71

datawrite1;>tabstrc--recurs-tabbuff--71_3
dataread1;;tabstrc--recurs-tabbuff--71_3
datawrite1;>tabstrc--recurs-tabbuff_read--71_3
dataread1;;tabstrc--recurs-tabbuff_read--71_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--71_3
goto;>tabstrc--recurs-checkno--71_3
null;;tabstrc--recurs-checkyes--71_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--71
setreg2;+
add
datawrite1;>tabstrc--adrbuff--71

setreg1;>tabstrc--adrbuff--71

datawrite1;>tabstrc--recurs-tabbuff--71_4
dataread1;;tabstrc--recurs-tabbuff--71_4
datawrite1;>tabstrc--recurs-tabbuff_read--71_4
dataread1;;tabstrc--recurs-tabbuff_read--71_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--71_4
goto;>tabstrc--recurs-checkno--71_4
null;;tabstrc--recurs-checkyes--71_4
##set flag########
setreg1;>tabstrc--outbuff--71
datawrite1;>tabstrc--recurs-flag--71_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--71_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--71_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--71_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--71_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--71_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--71
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-73
goto;>goto--jumper-73
dataread1;>@1;goto--branch-73
datawrite1;>validcom
null;;goto--jumper-73
#conditional stop
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-74
goto;>goto--jumper-74
stop;;goto--branch-74

null;;goto--jumper-74
#conditional subroutine goto
dataread1;>validcom
dataread2;>@0
gotoif;>goto--branch-76
goto;>goto--jumper-76
setreg1;>goto--jumper-76;goto--branch-76
s1push1
goto;>invalid--label
null;;goto--jumper-76
#goto 
goto;>main--label
#label
null;;invalid--label
#prline
fopwri1;:U
fopwri1;:n
fopwri1;:k
fopwri1;:n
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;hello--label
#prline
fopwri1;:A
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:a
fopwri1;:\s
fopwri1;:g
fopwri1;:o
fopwri1;:o
fopwri1;:d
fopwri1;:\s
fopwri1;:d
fopwri1;:a
fopwri1;:y
fopwri1;:\s
fopwri1;:t
fopwri1;:o
fopwri1;:\s
fopwri1;:y
fopwri1;:o
fopwri1;:u
fopwri1;:,
fopwri1;:\s
fopwri1;:u
fopwri1;:s
fopwri1;:e
fopwri1;:r
fopwri1;:.
fopwri1;:\s
fopwri1;::
fopwri1;:D
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;help--label
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#prline
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:H
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;::
fopwri1;:\n
#prline
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;::
fopwri1;:\s
fopwri1;:t
fopwri1;:h
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:t
fopwri1;:e
fopwri1;:x
fopwri1;:t
fopwri1;:\n
#prline
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:l
fopwri1;:o
fopwri1;::
fopwri1;:\s
fopwri1;:p
fopwri1;:r
fopwri1;:i
fopwri1;:n
fopwri1;:t
fopwri1;:\s
fopwri1;:a
fopwri1;:\s
fopwri1;:g
fopwri1;:r
fopwri1;:e
fopwri1;:e
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:m
fopwri1;:e
fopwri1;:s
fopwri1;:s
fopwri1;:a
fopwri1;:g
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:q
fopwri1;:u
fopwri1;:i
fopwri1;:t
fopwri1;::
fopwri1;:\s
fopwri1;:q
fopwri1;:u
fopwri1;:i
fopwri1;:t
fopwri1;:.
fopwri1;:\n
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print newline
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#module include: line 101: comprompt as cp
includeas;comprompt,cp
#END OF FILE
