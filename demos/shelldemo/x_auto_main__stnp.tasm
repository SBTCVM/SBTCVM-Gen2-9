#SSTNPL COMPILER v0.2.2
#header
head-rname=auto_main
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "demos/shelldemo/auto_main.stnp
null;0;shell_entry_size
null;0;shell_entry_itersize
null;0;shell_entry_zeroit
null;0;shell_entry_buff
null;0;shell_entry_chbuff
null;10x0;shell_entry_clearbuffer
null;10x80;shell_entry_max
null;0;cmdflg
null;0;validcom
null;0++---;*0++---
null;+++---;*+++---
null;10x0;@0
null;10x1;@1
null;+++--0;*+++--0
null;:\n;:\n
null;:\x;:\x
null;10x0;getentry_tobuff_iter
null;10x0;getentry_pad_iter
#prline
fopwri1;:T
fopwri1;:h
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:a
fopwri1;:\s
fopwri1;:b
fopwri1;:a
fopwri1;:s
fopwri1;:i
fopwri1;:c
fopwri1;:\s
fopwri1;:m
fopwri1;:u
fopwri1;:l
fopwri1;:t
fopwri1;:i
fopwri1;:-
fopwri1;:c
fopwri1;:h
fopwri1;:a
fopwri1;:r
fopwri1;:a
fopwri1;:c
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:-
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:l
fopwri1;:\s
fopwri1;:d
fopwri1;:e
fopwri1;:m
fopwri1;:o
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:t
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:s
fopwri1;:\n
#label
null;;main--label
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:>
#goto (extra code stores away return address.)
setreg1;>goto--jumper-52
s1push1
goto;>getentry--label
null;;goto--jumper-52
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validcom
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>shell_entry_buffer--table
add
datawrite1;>tabstrc--adrbuff--65
null;;tabstrc--adrbuff--65
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--65
null;;tabstrc--outbuff--65
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--65

datawrite1;>tabstrc--recurs-tabbuff--65_1
dataread1;;tabstrc--recurs-tabbuff--65_1
datawrite1;>tabstrc--recurs-tabbuff_read--65_1
dataread1;;tabstrc--recurs-tabbuff_read--65_1

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--65_1
goto;>tabstrc--recurs-checkno--65_1
null;;tabstrc--recurs-checkyes--65_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--65
setreg2;+
add
datawrite1;>tabstrc--adrbuff--65

setreg1;>tabstrc--adrbuff--65

datawrite1;>tabstrc--recurs-tabbuff--65_2
dataread1;;tabstrc--recurs-tabbuff--65_2
datawrite1;>tabstrc--recurs-tabbuff_read--65_2
dataread1;;tabstrc--recurs-tabbuff_read--65_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--65_2
goto;>tabstrc--recurs-checkno--65_2
null;;tabstrc--recurs-checkyes--65_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--65
setreg2;+
add
datawrite1;>tabstrc--adrbuff--65

setreg1;>tabstrc--adrbuff--65

datawrite1;>tabstrc--recurs-tabbuff--65_3
dataread1;;tabstrc--recurs-tabbuff--65_3
datawrite1;>tabstrc--recurs-tabbuff_read--65_3
dataread1;;tabstrc--recurs-tabbuff_read--65_3

setreg2;:l


gotoif;>tabstrc--recurs-checkyes--65_3
goto;>tabstrc--recurs-checkno--65_3
null;;tabstrc--recurs-checkyes--65_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--65
setreg2;+
add
datawrite1;>tabstrc--adrbuff--65

setreg1;>tabstrc--adrbuff--65

datawrite1;>tabstrc--recurs-tabbuff--65_4
dataread1;;tabstrc--recurs-tabbuff--65_4
datawrite1;>tabstrc--recurs-tabbuff_read--65_4
dataread1;;tabstrc--recurs-tabbuff_read--65_4

setreg2;:p


gotoif;>tabstrc--recurs-checkyes--65_4
goto;>tabstrc--recurs-checkno--65_4
null;;tabstrc--recurs-checkyes--65_4
##set flag########
setreg1;>tabstrc--outbuff--65
datawrite1;>tabstrc--recurs-flag--65_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--65_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--65_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--65_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--65_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--65_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--65
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-67
goto;>goto--jumper-67
dataread1;>@1;goto--branch-67
datawrite1;>validcom
null;;goto--jumper-67
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-68
goto;>goto--jumper-68
setreg1;>goto--jumper-68;goto--branch-68
s1push1
goto;>help--label
null;;goto--jumper-68
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>shell_entry_buffer--table
add
datawrite1;>tabstrc--adrbuff--70
null;;tabstrc--adrbuff--70
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--70
null;;tabstrc--outbuff--70
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_1
dataread1;;tabstrc--recurs-tabbuff--70_1
datawrite1;>tabstrc--recurs-tabbuff_read--70_1
dataread1;;tabstrc--recurs-tabbuff_read--70_1

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--70_1
goto;>tabstrc--recurs-checkno--70_1
null;;tabstrc--recurs-checkyes--70_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_2
dataread1;;tabstrc--recurs-tabbuff--70_2
datawrite1;>tabstrc--recurs-tabbuff_read--70_2
dataread1;;tabstrc--recurs-tabbuff_read--70_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--70_2
goto;>tabstrc--recurs-checkno--70_2
null;;tabstrc--recurs-checkyes--70_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_3
dataread1;;tabstrc--recurs-tabbuff--70_3
datawrite1;>tabstrc--recurs-tabbuff_read--70_3
dataread1;;tabstrc--recurs-tabbuff_read--70_3

setreg2;:l


gotoif;>tabstrc--recurs-checkyes--70_3
goto;>tabstrc--recurs-checkno--70_3
null;;tabstrc--recurs-checkyes--70_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_4
dataread1;;tabstrc--recurs-tabbuff--70_4
datawrite1;>tabstrc--recurs-tabbuff_read--70_4
dataread1;;tabstrc--recurs-tabbuff_read--70_4

setreg2;:l


gotoif;>tabstrc--recurs-checkyes--70_4
goto;>tabstrc--recurs-checkno--70_4
null;;tabstrc--recurs-checkyes--70_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_5
dataread1;;tabstrc--recurs-tabbuff--70_5
datawrite1;>tabstrc--recurs-tabbuff_read--70_5
dataread1;;tabstrc--recurs-tabbuff_read--70_5

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--70_5
goto;>tabstrc--recurs-checkno--70_5
null;;tabstrc--recurs-checkyes--70_5
##set flag########
setreg1;>tabstrc--outbuff--70
datawrite1;>tabstrc--recurs-flag--70_5
setreg1;+
datawrite1;;tabstrc--recurs-flag--70_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--70
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-72
goto;>goto--jumper-72
dataread1;>@1;goto--branch-72
datawrite1;>validcom
null;;goto--jumper-72
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-73
goto;>goto--jumper-73
setreg1;>goto--jumper-73;goto--branch-73
s1push1
goto;>hello--label
null;;goto--jumper-73
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>shell_entry_buffer--table
add
datawrite1;>tabstrc--adrbuff--75
null;;tabstrc--adrbuff--75
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--75
null;;tabstrc--outbuff--75
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--75

datawrite1;>tabstrc--recurs-tabbuff--75_1
dataread1;;tabstrc--recurs-tabbuff--75_1
datawrite1;>tabstrc--recurs-tabbuff_read--75_1
dataread1;;tabstrc--recurs-tabbuff_read--75_1

setreg2;:q


gotoif;>tabstrc--recurs-checkyes--75_1
goto;>tabstrc--recurs-checkno--75_1
null;;tabstrc--recurs-checkyes--75_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--75
setreg2;+
add
datawrite1;>tabstrc--adrbuff--75

setreg1;>tabstrc--adrbuff--75

datawrite1;>tabstrc--recurs-tabbuff--75_2
dataread1;;tabstrc--recurs-tabbuff--75_2
datawrite1;>tabstrc--recurs-tabbuff_read--75_2
dataread1;;tabstrc--recurs-tabbuff_read--75_2

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--75_2
goto;>tabstrc--recurs-checkno--75_2
null;;tabstrc--recurs-checkyes--75_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--75
setreg2;+
add
datawrite1;>tabstrc--adrbuff--75

setreg1;>tabstrc--adrbuff--75

datawrite1;>tabstrc--recurs-tabbuff--75_3
dataread1;;tabstrc--recurs-tabbuff--75_3
datawrite1;>tabstrc--recurs-tabbuff_read--75_3
dataread1;;tabstrc--recurs-tabbuff_read--75_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--75_3
goto;>tabstrc--recurs-checkno--75_3
null;;tabstrc--recurs-checkyes--75_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--75
setreg2;+
add
datawrite1;>tabstrc--adrbuff--75

setreg1;>tabstrc--adrbuff--75

datawrite1;>tabstrc--recurs-tabbuff--75_4
dataread1;;tabstrc--recurs-tabbuff--75_4
datawrite1;>tabstrc--recurs-tabbuff_read--75_4
dataread1;;tabstrc--recurs-tabbuff_read--75_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--75_4
goto;>tabstrc--recurs-checkno--75_4
null;;tabstrc--recurs-checkyes--75_4
##set flag########
setreg1;>tabstrc--outbuff--75
datawrite1;>tabstrc--recurs-flag--75_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--75_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--75_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--75_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--75_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--75_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--75
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-77
goto;>goto--jumper-77
dataread1;>@1;goto--branch-77
datawrite1;>validcom
null;;goto--jumper-77
#conditional stop
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-78
goto;>goto--jumper-78
stop;;goto--branch-78

null;;goto--jumper-78
#conditional subroutine goto
dataread1;>validcom
dataread2;>@0
gotoif;>goto--branch-80
goto;>goto--jumper-80
setreg1;>goto--jumper-80;goto--branch-80
s1push1
goto;>invalid--label
null;;goto--jumper-80
#goto 
goto;>main--label
#label
null;;invalid--label
#prline
fopwri1;:U
fopwri1;:n
fopwri1;:k
fopwri1;:n
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;hello--label
#prline
fopwri1;:A
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:a
fopwri1;:\s
fopwri1;:g
fopwri1;:o
fopwri1;:o
fopwri1;:d
fopwri1;:\s
fopwri1;:d
fopwri1;:a
fopwri1;:y
fopwri1;:\s
fopwri1;:t
fopwri1;:o
fopwri1;:\s
fopwri1;:y
fopwri1;:o
fopwri1;:u
fopwri1;:,
fopwri1;:\s
fopwri1;:u
fopwri1;:s
fopwri1;:e
fopwri1;:r
fopwri1;:.
fopwri1;:\s
fopwri1;::
fopwri1;:D
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;help--label
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#prline
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:H
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;::
fopwri1;:\n
#prline
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;::
fopwri1;:\s
fopwri1;:t
fopwri1;:h
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:t
fopwri1;:e
fopwri1;:x
fopwri1;:t
fopwri1;:\n
#prline
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:l
fopwri1;:o
fopwri1;::
fopwri1;:\s
fopwri1;:p
fopwri1;:r
fopwri1;:i
fopwri1;:n
fopwri1;:t
fopwri1;:\s
fopwri1;:a
fopwri1;:\s
fopwri1;:g
fopwri1;:r
fopwri1;:e
fopwri1;:e
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:m
fopwri1;:e
fopwri1;:s
fopwri1;:s
fopwri1;:a
fopwri1;:g
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:q
fopwri1;:u
fopwri1;:i
fopwri1;:t
fopwri1;::
fopwri1;:\s
fopwri1;:q
fopwri1;:u
fopwri1;:i
fopwri1;:t
fopwri1;:.
fopwri1;:\n
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print newline
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#table width=85, height=1
null;;shell_entry_buffer--table
#tpad
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
null;0
#label
null;;getentry--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_size
#label
null;;getentry_loop--label
#keprompt: prompt for single keypress, continue only when keypress is received.
setreg2;0
iowrite1;>io.ttyrd
ioread1;>io.ttyrd;keyprompt--loop-120
gotoif;>keyprompt--loop-120
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_chbuff
#conditional goto
dataread1;>shell_entry_size
dataread2;>@0
gotoif;>goto--branch-122
goto;>goto--jumper-122
setreg1;>goto--jumper-122;goto--branch-122
goto;>shell_entry_skipnewline--label
null;;goto--jumper-122
#conditional subroutine goto
dataread1;>shell_entry_chbuff
dataread2;>:\n
gotoif;>goto--branch-123
goto;>goto--jumper-123
setreg1;>goto--jumper-123;goto--branch-123
s1push1
goto;>getentry_tobuff--label
null;;goto--jumper-123
#conditional return
dataread1;>shell_entry_chbuff
dataread2;>:\n
gotoif;>goto--branch-124
goto;>goto--jumper-124
s1pop1;;goto--branch-124
gotoreg1
null;;goto--jumper-124
#label
null;;shell_entry_skipnewline--label
#conditional goto
dataread1;>shell_entry_chbuff
dataread2;>:\n
gotoif;>goto--branch-127
goto;>goto--jumper-127
setreg1;>goto--jumper-127;goto--branch-127
goto;>getentry_loop--label
null;;goto--jumper-127
#conditional subroutine goto
dataread1;>shell_entry_chbuff
dataread2;>:\x
gotoif;>goto--branch-129
goto;>goto--jumper-129
setreg1;>goto--jumper-129;goto--branch-129
s1push1
goto;>getentry_backone--label
null;;goto--jumper-129
#conditional goto
dataread1;>shell_entry_chbuff
dataread2;>:\x
gotoif;>goto--branch-130
goto;>goto--jumper-130
setreg1;>goto--jumper-130;goto--branch-130
goto;>getentry_loop--label
null;;goto--jumper-130
#conditional goto
dataread1;>shell_entry_size
dataread2;>shell_entry_max
gotoif;>goto--branch-133
goto;>goto--jumper-133
setreg1;>goto--jumper-133;goto--branch-133
goto;>getentry_loop--label
null;;goto--jumper-133
#Dump (character)
dataread1;>shell_entry_chbuff
iowrite1;>io.ttywr
#add (2op math)
dataread1;>shell_entry_size
dataread2;>@1
add
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_size
#get(1) (may be used with set, or asm code)
dataread1;>shell_entry_chbuff
#stack push (uses stack 2)
s2push1
#goto 
goto;>getentry_loop--label
#label
null;;getentry_backone--label
#conditional return
dataread1;>shell_entry_size
dataread2;>@0
gotoif;>goto--branch-144
goto;>goto--jumper-144
s1pop1;;goto--branch-144
gotoreg1
null;;goto--jumper-144
#Dump (character)
dataread1;>:\x
iowrite1;>io.ttywr
#stack pop (uses stack 2)
s2pop1
#subtract (2op math)
dataread1;>shell_entry_size
dataread2;>@1
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_size
#return from subroutine.
s1pop1
gotoreg1
#label
null;;getentry_tobuff--label
#stack reverse (uses stack 2)
s2reverse
#subtract (2op math)
dataread1;>shell_entry_size
dataread2;>@1
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_itersize
#add (2op math)
dataread1;>shell_entry_size
dataread2;>@1
add
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_zeroit
#Upward range iterator
dataread1;>@0
datawrite1;>getentry_tobuff_iter
setreg1;>uiter-retpos-158;uiter-loopback-158
s1push1
goto;>getentry_tobuff_loop--label
dataread1;>getentry_tobuff_iter;uiter-retpos-158
setreg2;10x1
add
datawrite1;>getentry_tobuff_iter
dataread2;>shell_entry_itersize
gotoifless;>uiter-loopback-158
gotoif;>uiter-loopback-158

#Upward range iterator
dataread1;>shell_entry_size
datawrite1;>getentry_pad_iter
setreg1;>uiter-retpos-159;uiter-loopback-159
s1push1
goto;>getentry_pad--label
dataread1;>getentry_pad_iter;uiter-retpos-159
setreg2;10x1
add
datawrite1;>getentry_pad_iter
dataread2;>shell_entry_zeroit
gotoifless;>uiter-loopback-159
gotoif;>uiter-loopback-159

#conditional return
dataread1;>shell_entry_clearbuffer
dataread2;>@0
gotoif;>goto--branch-160
goto;>goto--jumper-160
s1pop1;;goto--branch-160
gotoreg1
null;;goto--jumper-160
#Upward range iterator
dataread1;>shell_entry_zeroit
datawrite1;>getentry_pad_iter
setreg1;>uiter-retpos-161;uiter-loopback-161
s1push1
goto;>getentry_pad--label
dataread1;>getentry_pad_iter;uiter-retpos-161
setreg2;10x1
add
datawrite1;>getentry_pad_iter
dataread2;>shell_entry_max
gotoifless;>uiter-loopback-161
gotoif;>uiter-loopback-161

#return from subroutine.
s1pop1
gotoreg1
#label
null;;getentry_tobuff_loop--label
#stack pop (uses stack 2)
s2pop1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>shell_entry_buff
#SSTNPL table write instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>getentry_tobuff_iter
add
setreg2;10x1
add
setreg2;>shell_entry_buffer--table
add
datawrite1;>tabw--adrbuff--168
dataread1;>shell_entry_buff
datawrite1;;tabw--adrbuff--168
#return from subroutine.
s1pop1
gotoreg1
#label
null;;getentry_pad--label
#SSTNPL table write instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>getentry_pad_iter
add
setreg2;10x1
add
setreg2;>shell_entry_buffer--table
add
datawrite1;>tabw--adrbuff--173
dataread1;>@0
datawrite1;;tabw--adrbuff--173
#return from subroutine.
s1pop1
gotoreg1
#END OF FILE
