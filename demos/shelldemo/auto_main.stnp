prline This is a basic multi-character-command shell demo.
prline type 'help' for commands


#Uses SSTNPLs tabstrc instruction, and some stack/table-based input code,
#	to create a command shell, complete with multi-character commands,
#	with no restrictions on command names, other than an 80-character limit,
#	and no cases as such:
#			load
#			load2
#		this is invalid. instead, when a command has a suffixed variant, do this:
#			load1
#			load2


########################
##Entry Code Variables
var shell_entry_size=0
#one less than shell_entry_size, for indexing
var shell_entry_itersize=0


var shell_entry_max=@80
var shell_entry_buff=0
var shell_entry_chbuff=0
######################


var cmdflg=0
var validcom=0

label main
	textcolor *0++---
	print >
	#read value via specialized input read function
	gsub getentry
	textcolor *+++---
	newline
	#use specialized SSTNPL table-string matcher to check for command.
	#arguments: [table],[xoffset],[ypos],[string_to_match]
	#xoffset can be used to start at arbitrary locations in table row 
	#   (x position). i.e. for parsing arguments.
	#ypos (table y position) is only useful if you are using a table to store
	#   code for an interpreter.
	
	val 0
	set validcom
	
	tabstrc shell_entry_buffer,@0,@0,help
		set cmdflg
		if cmdflg,@1 =validcom @1
		if cmdflg,@1 gsub help
	
	tabstrc shell_entry_buffer,@0,@0,hello
		set cmdflg
		if cmdflg,@1 =validcom @1
		if cmdflg,@1 gsub hello
	
	tabstrc shell_entry_buffer,@0,@0,quit
		set cmdflg
		if cmdflg,@1 =validcom @1
		if cmdflg,@1 stop
	
	if validcom,@0 gsub invalid
	
goto main

label invalid
prline Unknown command
return

#hello command
label hello
prline And a good day to you, user. :D
return

#help command
label help
textcolor *+++--0
prline command Help:
prline help: this text
prline hello: print a greeting message.
prline quit: quit.
textcolor *+++---
newline
return



####################################
###The following code is related to reading the commands 
###and placing them in the table: 'shell_entry_buffer'

#entry buffer
table shell_entry_buffer,80,1
tpad 80


label getentry
	val 0
	set shell_entry_size
	label getentry_loop
		keyprompt
		set shell_entry_chbuff
		if shell_entry_size,@0 goto shell_entry_skipnewline
		if shell_entry_chbuff,:\n gsub getentry_tobuff
		if shell_entry_chbuff,:\n return
		
		label shell_entry_skipnewline
		if shell_entry_chbuff,:\n goto getentry_loop
		
		if shell_entry_chbuff,:\x gsub getentry_backone
		if shell_entry_chbuff,:\x goto getentry_loop
		
		
		if shell_entry_size,shell_entry_max goto getentry_loop
		chardump shell_entry_chbuff
		add shell_entry_size,@1
		set shell_entry_size
		
		get shell_entry_chbuff
		push
	goto getentry_loop


label getentry_backone
	if shell_entry_size,@0 return
	chardump :\x
	pop
	sub shell_entry_size,@1
	set shell_entry_size
return


label getentry_tobuff
	stackrev
	sub shell_entry_size,@1
	set shell_entry_itersize
	uiter getentry_tobuff_iter,getentry_tobuff_loop,@0,shell_entry_itersize
	return

label getentry_tobuff_loop
	pop
	set shell_entry_buff
	tabw shell_entry_buffer,getentry_tobuff_iter,@0,shell_entry_buff
return


