#SSTNPL COMPILER v0.3.0
#header
head-rname=command
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "apps/dos/command/command.stnp
null;0;sysbak
null;10x1;$true
null;10x1;@1
null;10x0;$false
null;+++---;*+++---
null;0;cmdflg
null;0;validflg
null;:A;drive
null;0+0---;*0+0---
null;10x0;@0
null;10x4;@4
null;10x3;@3
null;10x0;run_iter
null;:R;:R
null;:B;:B
null;:A;:A
null;:0;driveref
null;0;invalid_charcheck
null;0;extflg
null;0;extoffset
null;++0---;*++0---
null;10x2;@2
null;::;::
null;:0;:0
null;:1;:1
null;:2;:2
null;0;run_s_tmp
null;0;run_tobuffer_flg
null;:\s;:\s
null;0++---;*0++---
null;0;vdi_vdioutput_buffer
null;10x0;vdi_iter
null;+++0--;*+++0--
null;+++00-;*+++00-
null;+++-0-;*+++-0-
null;+++-00;*+++-00
null;+++--0;*+++--0
null;+++0-0;*+++0-0
#conditional goto
dataread1;>sysbak
dataread2;>$true
gotoif;>goto--branch-4
goto;>goto--jumper-4
setreg1;>goto--jumper-4;goto--branch-4
goto;>startup--label
null;;goto--jumper-4
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#label
null;;startup--label
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-14
goto;>goto--jumper-14
setreg1;>goto--jumper-14;goto--branch-14
s1push1
goto;>version--label
null;;goto--jumper-14
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-15
goto;>goto--jumper-15
setreg1;>goto--jumper-15;goto--branch-15
s1push1
goto;>help_ready_splash--label
null;;goto--jumper-15
#val (used with set to change variable value during runtime.)
setreg1;10x1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>sysbak
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#buffer 2 reset
iowrite1;>buffer.2.reset
#goto 
goto;>main--label
#label
null;;help_ready_splash--label
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#prline
fopwri1;:T
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:?
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:\s
fopwri1;:R
fopwri1;:E
fopwri1;:A
fopwri1;:D
fopwri1;:Y
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;main--label
#Set text colors
dataread1;>*0+0---
iowrite1;>io.textcolor
#Dump (character)
dataread1;>drive
iowrite1;>io.ttywr
#print
fopwri1;::
fopwri1;:\b
fopwri1;:>
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#goto (extra code stores away return address.)
setreg1;>goto--jumper-50
s1push1
goto;>cp.getentry--label
null;;goto--jumper-50
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validflg
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--56
null;;tabstrc--adrbuff--56
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--56
null;;tabstrc--outbuff--56
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--56

datawrite1;>tabstrc--recurs-tabbuff--56_1
dataread1;;tabstrc--recurs-tabbuff--56_1
datawrite1;>tabstrc--recurs-tabbuff_read--56_1
dataread1;;tabstrc--recurs-tabbuff_read--56_1

setreg2;:?


gotoif;>tabstrc--recurs-checkyes--56_1
goto;>tabstrc--recurs-checkno--56_1
null;;tabstrc--recurs-checkyes--56_1
##set flag########
setreg1;>tabstrc--outbuff--56
datawrite1;>tabstrc--recurs-flag--56_1
setreg1;+
datawrite1;;tabstrc--recurs-flag--56_1
#recursionskip endpoint
null;;tabstrc--recurs-checkno--56_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--56
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-58
goto;>goto--jumper-58
setreg1;>goto--jumper-58;goto--branch-58
s1push1
goto;>help--label
null;;goto--jumper-58
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-59
goto;>goto--jumper-59
dataread1;>@1;goto--branch-59
datawrite1;>validflg
null;;goto--jumper-59
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--60
null;;tabstrc--adrbuff--60
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--60
null;;tabstrc--outbuff--60
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--60

datawrite1;>tabstrc--recurs-tabbuff--60_1
dataread1;;tabstrc--recurs-tabbuff--60_1
datawrite1;>tabstrc--recurs-tabbuff_read--60_1
dataread1;;tabstrc--recurs-tabbuff_read--60_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--60_1
goto;>tabstrc--recurs-checkno--60_1
null;;tabstrc--recurs-checkyes--60_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--60
setreg2;+
add
datawrite1;>tabstrc--adrbuff--60

setreg1;>tabstrc--adrbuff--60

datawrite1;>tabstrc--recurs-tabbuff--60_2
dataread1;;tabstrc--recurs-tabbuff--60_2
datawrite1;>tabstrc--recurs-tabbuff_read--60_2
dataread1;;tabstrc--recurs-tabbuff_read--60_2

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--60_2
goto;>tabstrc--recurs-checkno--60_2
null;;tabstrc--recurs-checkyes--60_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--60
setreg2;+
add
datawrite1;>tabstrc--adrbuff--60

setreg1;>tabstrc--adrbuff--60

datawrite1;>tabstrc--recurs-tabbuff--60_3
dataread1;;tabstrc--recurs-tabbuff--60_3
datawrite1;>tabstrc--recurs-tabbuff_read--60_3
dataread1;;tabstrc--recurs-tabbuff_read--60_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--60_3
goto;>tabstrc--recurs-checkno--60_3
null;;tabstrc--recurs-checkyes--60_3
##set flag########
setreg1;>tabstrc--outbuff--60
datawrite1;>tabstrc--recurs-flag--60_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--60_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--60_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--60_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--60_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--60
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-62
goto;>goto--jumper-62
setreg1;>goto--jumper-62;goto--branch-62
s1push1
goto;>vdi--label
null;;goto--jumper-62
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-63
goto;>goto--jumper-63
dataread1;>@1;goto--branch-63
datawrite1;>validflg
null;;goto--jumper-63
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--64
null;;tabstrc--adrbuff--64
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--64
null;;tabstrc--outbuff--64
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_1
dataread1;;tabstrc--recurs-tabbuff--64_1
datawrite1;>tabstrc--recurs-tabbuff_read--64_1
dataread1;;tabstrc--recurs-tabbuff_read--64_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--64_1
goto;>tabstrc--recurs-checkno--64_1
null;;tabstrc--recurs-checkyes--64_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_2
dataread1;;tabstrc--recurs-tabbuff--64_2
datawrite1;>tabstrc--recurs-tabbuff_read--64_2
dataread1;;tabstrc--recurs-tabbuff_read--64_2

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--64_2
goto;>tabstrc--recurs-checkno--64_2
null;;tabstrc--recurs-checkyes--64_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_3
dataread1;;tabstrc--recurs-tabbuff--64_3
datawrite1;>tabstrc--recurs-tabbuff_read--64_3
dataread1;;tabstrc--recurs-tabbuff_read--64_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--64_3
goto;>tabstrc--recurs-checkno--64_3
null;;tabstrc--recurs-checkyes--64_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_4
dataread1;;tabstrc--recurs-tabbuff--64_4
datawrite1;>tabstrc--recurs-tabbuff_read--64_4
dataread1;;tabstrc--recurs-tabbuff_read--64_4

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--64_4
goto;>tabstrc--recurs-checkno--64_4
null;;tabstrc--recurs-checkyes--64_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_5
dataread1;;tabstrc--recurs-tabbuff--64_5
datawrite1;>tabstrc--recurs-tabbuff_read--64_5
dataread1;;tabstrc--recurs-tabbuff_read--64_5

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--64_5
goto;>tabstrc--recurs-checkno--64_5
null;;tabstrc--recurs-checkyes--64_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_6
dataread1;;tabstrc--recurs-tabbuff--64_6
datawrite1;>tabstrc--recurs-tabbuff_read--64_6
dataread1;;tabstrc--recurs-tabbuff_read--64_6

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--64_6
goto;>tabstrc--recurs-checkno--64_6
null;;tabstrc--recurs-checkyes--64_6
##set flag########
setreg1;>tabstrc--outbuff--64
datawrite1;>tabstrc--recurs-flag--64_6
setreg1;+
datawrite1;;tabstrc--recurs-flag--64_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--64_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--64_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--64_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--64_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--64_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--64_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--64
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-66
goto;>goto--jumper-66
setreg1;>goto--jumper-66;goto--branch-66
s1push1
goto;>drives--label
null;;goto--jumper-66
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-67
goto;>goto--jumper-67
dataread1;>@1;goto--branch-67
datawrite1;>validflg
null;;goto--jumper-67
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--68
null;;tabstrc--adrbuff--68
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--68
null;;tabstrc--outbuff--68
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--68

datawrite1;>tabstrc--recurs-tabbuff--68_1
dataread1;;tabstrc--recurs-tabbuff--68_1
datawrite1;>tabstrc--recurs-tabbuff_read--68_1
dataread1;;tabstrc--recurs-tabbuff_read--68_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--68_1
goto;>tabstrc--recurs-checkno--68_1
null;;tabstrc--recurs-checkyes--68_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--68
setreg2;+
add
datawrite1;>tabstrc--adrbuff--68

setreg1;>tabstrc--adrbuff--68

datawrite1;>tabstrc--recurs-tabbuff--68_2
dataread1;;tabstrc--recurs-tabbuff--68_2
datawrite1;>tabstrc--recurs-tabbuff_read--68_2
dataread1;;tabstrc--recurs-tabbuff_read--68_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--68_2
goto;>tabstrc--recurs-checkno--68_2
null;;tabstrc--recurs-checkyes--68_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--68
setreg2;+
add
datawrite1;>tabstrc--adrbuff--68

setreg1;>tabstrc--adrbuff--68

datawrite1;>tabstrc--recurs-tabbuff--68_3
dataread1;;tabstrc--recurs-tabbuff--68_3
datawrite1;>tabstrc--recurs-tabbuff_read--68_3
dataread1;;tabstrc--recurs-tabbuff_read--68_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--68_3
goto;>tabstrc--recurs-checkno--68_3
null;;tabstrc--recurs-checkyes--68_3
##set flag########
setreg1;>tabstrc--outbuff--68
datawrite1;>tabstrc--recurs-flag--68_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--68_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--68_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--68_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--68_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--68
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-70
goto;>goto--jumper-70
setreg1;>goto--jumper-70;goto--branch-70
s1push1
goto;>version--label
null;;goto--jumper-70
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-71
goto;>goto--jumper-71
dataread1;>@1;goto--branch-71
datawrite1;>validflg
null;;goto--jumper-71
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--72
null;;tabstrc--adrbuff--72
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--72
null;;tabstrc--outbuff--72
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_1
dataread1;;tabstrc--recurs-tabbuff--72_1
datawrite1;>tabstrc--recurs-tabbuff_read--72_1
dataread1;;tabstrc--recurs-tabbuff_read--72_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--72_1
goto;>tabstrc--recurs-checkno--72_1
null;;tabstrc--recurs-checkyes--72_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_2
dataread1;;tabstrc--recurs-tabbuff--72_2
datawrite1;>tabstrc--recurs-tabbuff_read--72_2
dataread1;;tabstrc--recurs-tabbuff_read--72_2

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--72_2
goto;>tabstrc--recurs-checkno--72_2
null;;tabstrc--recurs-checkyes--72_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_3
dataread1;;tabstrc--recurs-tabbuff--72_3
datawrite1;>tabstrc--recurs-tabbuff_read--72_3
dataread1;;tabstrc--recurs-tabbuff_read--72_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--72_3
goto;>tabstrc--recurs-checkno--72_3
null;;tabstrc--recurs-checkyes--72_3
##set flag########
setreg1;>tabstrc--outbuff--72
datawrite1;>tabstrc--recurs-flag--72_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--72_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--72_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--72_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--72_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--72
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-74
goto;>goto--jumper-74
setreg1;>goto--jumper-74;goto--branch-74
s1push1
goto;>directory_list--label
null;;goto--jumper-74
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-75
goto;>goto--jumper-75
dataread1;>@1;goto--branch-75
datawrite1;>validflg
null;;goto--jumper-75
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--76
null;;tabstrc--adrbuff--76
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--76
null;;tabstrc--outbuff--76
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_1
dataread1;;tabstrc--recurs-tabbuff--76_1
datawrite1;>tabstrc--recurs-tabbuff_read--76_1
dataread1;;tabstrc--recurs-tabbuff_read--76_1

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--76_1
goto;>tabstrc--recurs-checkno--76_1
null;;tabstrc--recurs-checkyes--76_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_2
dataread1;;tabstrc--recurs-tabbuff--76_2
datawrite1;>tabstrc--recurs-tabbuff_read--76_2
dataread1;;tabstrc--recurs-tabbuff_read--76_2

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--76_2
goto;>tabstrc--recurs-checkno--76_2
null;;tabstrc--recurs-checkyes--76_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_3
dataread1;;tabstrc--recurs-tabbuff--76_3
datawrite1;>tabstrc--recurs-tabbuff_read--76_3
dataread1;;tabstrc--recurs-tabbuff_read--76_3

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--76_3
goto;>tabstrc--recurs-checkno--76_3
null;;tabstrc--recurs-checkyes--76_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_4
dataread1;;tabstrc--recurs-tabbuff--76_4
datawrite1;>tabstrc--recurs-tabbuff_read--76_4
dataread1;;tabstrc--recurs-tabbuff_read--76_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--76_4
goto;>tabstrc--recurs-checkno--76_4
null;;tabstrc--recurs-checkyes--76_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_5
dataread1;;tabstrc--recurs-tabbuff--76_5
datawrite1;>tabstrc--recurs-tabbuff_read--76_5
dataread1;;tabstrc--recurs-tabbuff_read--76_5

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--76_5
goto;>tabstrc--recurs-checkno--76_5
null;;tabstrc--recurs-checkyes--76_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_6
dataread1;;tabstrc--recurs-tabbuff--76_6
datawrite1;>tabstrc--recurs-tabbuff_read--76_6
dataread1;;tabstrc--recurs-tabbuff_read--76_6

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--76_6
goto;>tabstrc--recurs-checkno--76_6
null;;tabstrc--recurs-checkyes--76_6
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_7
dataread1;;tabstrc--recurs-tabbuff--76_7
datawrite1;>tabstrc--recurs-tabbuff_read--76_7
dataread1;;tabstrc--recurs-tabbuff_read--76_7

setreg2;:w


gotoif;>tabstrc--recurs-checkyes--76_7
goto;>tabstrc--recurs-checkno--76_7
null;;tabstrc--recurs-checkyes--76_7
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_8
dataread1;;tabstrc--recurs-tabbuff--76_8
datawrite1;>tabstrc--recurs-tabbuff_read--76_8
dataread1;;tabstrc--recurs-tabbuff_read--76_8

setreg2;:n


gotoif;>tabstrc--recurs-checkyes--76_8
goto;>tabstrc--recurs-checkno--76_8
null;;tabstrc--recurs-checkyes--76_8
##set flag########
setreg1;>tabstrc--outbuff--76
datawrite1;>tabstrc--recurs-flag--76_8
setreg1;+
datawrite1;;tabstrc--recurs-flag--76_8
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_8
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_7
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--76
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-78
goto;>goto--jumper-78
setreg1;>goto--jumper-78;goto--branch-78
s1push1
goto;>shutdown--label
null;;goto--jumper-78
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-79
goto;>goto--jumper-79
dataread1;>@1;goto--branch-79
datawrite1;>validflg
null;;goto--jumper-79
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--82
null;;tabstrc--adrbuff--82
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--82
null;;tabstrc--outbuff--82
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--82

datawrite1;>tabstrc--recurs-tabbuff--82_1
dataread1;;tabstrc--recurs-tabbuff--82_1
datawrite1;>tabstrc--recurs-tabbuff_read--82_1
dataread1;;tabstrc--recurs-tabbuff_read--82_1

setreg2;:a


gotoif;>tabstrc--recurs-checkyes--82_1
goto;>tabstrc--recurs-checkno--82_1
null;;tabstrc--recurs-checkyes--82_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--82
setreg2;+
add
datawrite1;>tabstrc--adrbuff--82

setreg1;>tabstrc--adrbuff--82

datawrite1;>tabstrc--recurs-tabbuff--82_2
dataread1;;tabstrc--recurs-tabbuff--82_2
datawrite1;>tabstrc--recurs-tabbuff_read--82_2
dataread1;;tabstrc--recurs-tabbuff_read--82_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--82_2
goto;>tabstrc--recurs-checkno--82_2
null;;tabstrc--recurs-checkyes--82_2
##set flag########
setreg1;>tabstrc--outbuff--82
datawrite1;>tabstrc--recurs-flag--82_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--82_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--82_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--82_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--82
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-84
goto;>goto--jumper-84
setreg1;>goto--jumper-84;goto--branch-84
s1push1
goto;>driveA--label
null;;goto--jumper-84
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-85
goto;>goto--jumper-85
dataread1;>@1;goto--branch-85
datawrite1;>validflg
null;;goto--jumper-85
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--86
null;;tabstrc--adrbuff--86
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--86
null;;tabstrc--outbuff--86
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--86

datawrite1;>tabstrc--recurs-tabbuff--86_1
dataread1;;tabstrc--recurs-tabbuff--86_1
datawrite1;>tabstrc--recurs-tabbuff_read--86_1
dataread1;;tabstrc--recurs-tabbuff_read--86_1

setreg2;:A


gotoif;>tabstrc--recurs-checkyes--86_1
goto;>tabstrc--recurs-checkno--86_1
null;;tabstrc--recurs-checkyes--86_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--86
setreg2;+
add
datawrite1;>tabstrc--adrbuff--86

setreg1;>tabstrc--adrbuff--86

datawrite1;>tabstrc--recurs-tabbuff--86_2
dataread1;;tabstrc--recurs-tabbuff--86_2
datawrite1;>tabstrc--recurs-tabbuff_read--86_2
dataread1;;tabstrc--recurs-tabbuff_read--86_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--86_2
goto;>tabstrc--recurs-checkno--86_2
null;;tabstrc--recurs-checkyes--86_2
##set flag########
setreg1;>tabstrc--outbuff--86
datawrite1;>tabstrc--recurs-flag--86_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--86_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--86_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--86_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--86
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-88
goto;>goto--jumper-88
setreg1;>goto--jumper-88;goto--branch-88
s1push1
goto;>driveA--label
null;;goto--jumper-88
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-89
goto;>goto--jumper-89
dataread1;>@1;goto--branch-89
datawrite1;>validflg
null;;goto--jumper-89
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--91
null;;tabstrc--adrbuff--91
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--91
null;;tabstrc--outbuff--91
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--91

datawrite1;>tabstrc--recurs-tabbuff--91_1
dataread1;;tabstrc--recurs-tabbuff--91_1
datawrite1;>tabstrc--recurs-tabbuff_read--91_1
dataread1;;tabstrc--recurs-tabbuff_read--91_1

setreg2;:b


gotoif;>tabstrc--recurs-checkyes--91_1
goto;>tabstrc--recurs-checkno--91_1
null;;tabstrc--recurs-checkyes--91_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--91
setreg2;+
add
datawrite1;>tabstrc--adrbuff--91

setreg1;>tabstrc--adrbuff--91

datawrite1;>tabstrc--recurs-tabbuff--91_2
dataread1;;tabstrc--recurs-tabbuff--91_2
datawrite1;>tabstrc--recurs-tabbuff_read--91_2
dataread1;;tabstrc--recurs-tabbuff_read--91_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--91_2
goto;>tabstrc--recurs-checkno--91_2
null;;tabstrc--recurs-checkyes--91_2
##set flag########
setreg1;>tabstrc--outbuff--91
datawrite1;>tabstrc--recurs-flag--91_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--91_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--91_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--91_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--91
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-93
goto;>goto--jumper-93
setreg1;>goto--jumper-93;goto--branch-93
s1push1
goto;>driveB--label
null;;goto--jumper-93
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-94
goto;>goto--jumper-94
dataread1;>@1;goto--branch-94
datawrite1;>validflg
null;;goto--jumper-94
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--95
null;;tabstrc--adrbuff--95
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--95
null;;tabstrc--outbuff--95
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--95

datawrite1;>tabstrc--recurs-tabbuff--95_1
dataread1;;tabstrc--recurs-tabbuff--95_1
datawrite1;>tabstrc--recurs-tabbuff_read--95_1
dataread1;;tabstrc--recurs-tabbuff_read--95_1

setreg2;:B


gotoif;>tabstrc--recurs-checkyes--95_1
goto;>tabstrc--recurs-checkno--95_1
null;;tabstrc--recurs-checkyes--95_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--95
setreg2;+
add
datawrite1;>tabstrc--adrbuff--95

setreg1;>tabstrc--adrbuff--95

datawrite1;>tabstrc--recurs-tabbuff--95_2
dataread1;;tabstrc--recurs-tabbuff--95_2
datawrite1;>tabstrc--recurs-tabbuff_read--95_2
dataread1;;tabstrc--recurs-tabbuff_read--95_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--95_2
goto;>tabstrc--recurs-checkno--95_2
null;;tabstrc--recurs-checkyes--95_2
##set flag########
setreg1;>tabstrc--outbuff--95
datawrite1;>tabstrc--recurs-flag--95_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--95_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--95_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--95_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--95
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-97
goto;>goto--jumper-97
setreg1;>goto--jumper-97;goto--branch-97
s1push1
goto;>driveB--label
null;;goto--jumper-97
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-98
goto;>goto--jumper-98
dataread1;>@1;goto--branch-98
datawrite1;>validflg
null;;goto--jumper-98
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--100
null;;tabstrc--adrbuff--100
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--100
null;;tabstrc--outbuff--100
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--100

datawrite1;>tabstrc--recurs-tabbuff--100_1
dataread1;;tabstrc--recurs-tabbuff--100_1
datawrite1;>tabstrc--recurs-tabbuff_read--100_1
dataread1;;tabstrc--recurs-tabbuff_read--100_1

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--100_1
goto;>tabstrc--recurs-checkno--100_1
null;;tabstrc--recurs-checkyes--100_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--100
setreg2;+
add
datawrite1;>tabstrc--adrbuff--100

setreg1;>tabstrc--adrbuff--100

datawrite1;>tabstrc--recurs-tabbuff--100_2
dataread1;;tabstrc--recurs-tabbuff--100_2
datawrite1;>tabstrc--recurs-tabbuff_read--100_2
dataread1;;tabstrc--recurs-tabbuff_read--100_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--100_2
goto;>tabstrc--recurs-checkno--100_2
null;;tabstrc--recurs-checkyes--100_2
##set flag########
setreg1;>tabstrc--outbuff--100
datawrite1;>tabstrc--recurs-flag--100_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--100_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--100_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--100_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--100
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-102
goto;>goto--jumper-102
setreg1;>goto--jumper-102;goto--branch-102
s1push1
goto;>driveR--label
null;;goto--jumper-102
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-103
goto;>goto--jumper-103
dataread1;>@1;goto--branch-103
datawrite1;>validflg
null;;goto--jumper-103
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--104
null;;tabstrc--adrbuff--104
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--104
null;;tabstrc--outbuff--104
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--104

datawrite1;>tabstrc--recurs-tabbuff--104_1
dataread1;;tabstrc--recurs-tabbuff--104_1
datawrite1;>tabstrc--recurs-tabbuff_read--104_1
dataread1;;tabstrc--recurs-tabbuff_read--104_1

setreg2;:R


gotoif;>tabstrc--recurs-checkyes--104_1
goto;>tabstrc--recurs-checkno--104_1
null;;tabstrc--recurs-checkyes--104_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--104
setreg2;+
add
datawrite1;>tabstrc--adrbuff--104

setreg1;>tabstrc--adrbuff--104

datawrite1;>tabstrc--recurs-tabbuff--104_2
dataread1;;tabstrc--recurs-tabbuff--104_2
datawrite1;>tabstrc--recurs-tabbuff_read--104_2
dataread1;;tabstrc--recurs-tabbuff_read--104_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--104_2
goto;>tabstrc--recurs-checkno--104_2
null;;tabstrc--recurs-checkyes--104_2
##set flag########
setreg1;>tabstrc--outbuff--104
datawrite1;>tabstrc--recurs-flag--104_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--104_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--104_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--104_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--104
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-106
goto;>goto--jumper-106
setreg1;>goto--jumper-106;goto--branch-106
s1push1
goto;>driveR--label
null;;goto--jumper-106
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-107
goto;>goto--jumper-107
dataread1;>@1;goto--branch-107
datawrite1;>validflg
null;;goto--jumper-107
#conditional subroutine goto
dataread1;>validflg
dataread2;>@0
gotoif;>goto--branch-109
goto;>goto--jumper-109
setreg1;>goto--jumper-109;goto--branch-109
s1push1
goto;>invalid--label
null;;goto--jumper-109
#goto 
goto;>main--label
#label
null;;driveA--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-117
goto;>goto--jumper-117
setreg1;>goto--jumper-117;goto--branch-117
s1push1
goto;>extcheck--label
null;;goto--jumper-117
#conditional goto
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-118
goto;>goto--branch-118
setreg1;>goto--jumper-118;goto--branch-118
goto;>driveA_run--label
null;;goto--jumper-118
#val (used with set to change variable value during runtime.)
setreg1;:A
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveA_run--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-126
s1push1
goto;>run_send_setup--label
null;;goto--jumper-126
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-127;uiter-loopback-127
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-127
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-127
gotoif;>uiter-loopback-127

#goto (extra code stores away return address.)
setreg1;>goto--jumper-128
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-128
#goto (extra code stores away return address.)
setreg1;>goto--jumper-131
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-131
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveB--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional goto
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-137
goto;>goto--branch-137
setreg1;>goto--jumper-137;goto--branch-137
goto;>driveB_run--label
null;;goto--jumper-137
#val (used with set to change variable value during runtime.)
setreg1;:B
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveB_run--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-145
s1push1
goto;>run_send_setup--label
null;;goto--jumper-145
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-146;uiter-loopback-146
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-146
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-146
gotoif;>uiter-loopback-146

#goto (extra code stores away return address.)
setreg1;>goto--jumper-147
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-147
#goto (extra code stores away return address.)
setreg1;>goto--jumper-150
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-150
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveR--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-157
goto;>goto--jumper-157
setreg1;>goto--jumper-157;goto--branch-157
s1push1
goto;>extcheck--label
null;;goto--jumper-157
#conditional goto
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-159
goto;>goto--branch-159
setreg1;>goto--jumper-159;goto--branch-159
goto;>driveR_run--label
null;;goto--jumper-159
#val (used with set to change variable value during runtime.)
setreg1;:R
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveR_run--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-167
s1push1
goto;>run_send_setup--label
null;;goto--jumper-167
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-168;uiter-loopback-168
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-168
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-168
gotoif;>uiter-loopback-168

#goto (extra code stores away return address.)
setreg1;>goto--jumper-169
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-169
#goto (extra code stores away return address.)
setreg1;>goto--jumper-172
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-172
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list--label
#conditional subroutine goto
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-177
goto;>goto--jumper-177
setreg1;>goto--jumper-177;goto--branch-177
s1push1
goto;>directory_list_R--label
null;;goto--jumper-177
#conditional subroutine goto
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-178
goto;>goto--jumper-178
setreg1;>goto--jumper-178;goto--branch-178
s1push1
goto;>directory_list_B--label
null;;goto--jumper-178
#conditional subroutine goto
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-179
goto;>goto--jumper-179
setreg1;>goto--jumper-179;goto--branch-179
s1push1
goto;>directory_list_A--label
null;;goto--jumper-179
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_A--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:A
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-184;uiter-loopback-184
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-184
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-184
gotoif;>uiter-loopback-184

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-187;uiter-loopback-187
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-187
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-187
gotoif;>uiter-loopback-187

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-189
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-189
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_B--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:B
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-194;uiter-loopback-194
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-194
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-194
gotoif;>uiter-loopback-194

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-197;uiter-loopback-197
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-197
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-197
gotoif;>uiter-loopback-197

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-199
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-199
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_R--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-204;uiter-loopback-204
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-204
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-204
gotoif;>uiter-loopback-204

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-207;uiter-loopback-207
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-207
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-207
gotoif;>uiter-loopback-207

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-209
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-209
#return from subroutine.
s1pop1
gotoreg1
#label
null;;invalid--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-218
goto;>goto--jumper-218
setreg1;>goto--jumper-218;goto--branch-218
s1push1
goto;>extcheck--label
null;;goto--jumper-218
#Set text colors
dataread1;>*++0---
iowrite1;>io.textcolor
#conditional goto
dataread1;>cp.size
dataread2;>@2
gotoifless;>goto--branch-220
goto;>goto--jumper-220
setreg1;>goto--jumper-220;goto--branch-220
goto;>run_command--label
null;;goto--jumper-220
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>@1
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--223
dataread1;;tabr--adrbuff--223
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>invalid_charcheck
#conditional goto
dataread1;>invalid_charcheck
dataread2;>::
gotoif;>goto--jumper-225
goto;>goto--branch-225
setreg1;>goto--jumper-225;goto--branch-225
goto;>run_command--label
null;;goto--jumper-225
#prline
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:N
fopwri1;:o
fopwri1;:t
fopwri1;:\s
fopwri1;:V
fopwri1;:a
fopwri1;:l
fopwri1;:i
fopwri1;:d
fopwri1;:.
fopwri1;:\s
fopwri1;:s
fopwri1;:e
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:d
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:s
fopwri1;:'
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_command--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopset1;>io.ttywr
#conditional set
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-233
goto;>goto--jumper-233
dataread1;>:0;goto--branch-233
datawrite1;>driveref
null;;goto--jumper-233
#conditional set
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-234
goto;>goto--jumper-234
dataread1;>:1;goto--branch-234
datawrite1;>driveref
null;;goto--jumper-234
#conditional set
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-235
goto;>goto--jumper-235
dataread1;>:2;goto--branch-235
datawrite1;>driveref
null;;goto--jumper-235
#get(1) (may be used with set, or asm code)
dataread1;>driveref
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #237
iowrite1;>vdi.cli.in#SSTNPL Source Line: '237' 
#vdin
fopset1;>vdi.cli.in
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-239
s1push1
goto;>run_send_setup--label
null;;goto--jumper-239
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-240;uiter-loopback-240
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-240
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-240
gotoif;>uiter-loopback-240

#goto (extra code stores away return address.)
setreg1;>goto--jumper-241
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-241
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-245
s1push1
goto;>run_send_setup--label
null;;goto--jumper-245
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-246;uiter-loopback-246
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-246
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-246
gotoif;>uiter-loopback-246

#goto (extra code stores away return address.)
setreg1;>goto--jumper-247
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-247
#goto (extra code stores away return address.)
setreg1;>goto--jumper-249
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-249
#return from subroutine.
s1pop1
gotoreg1
#label
null;;extcheck--label
#return from subroutine.
s1pop1
gotoreg1
#subtract (2op math)
dataread1;>cp.size
dataread2;>@4
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extoffset
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>extoffset
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--259
null;;tabstrc--adrbuff--259
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--259
null;;tabstrc--outbuff--259
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--259

datawrite1;>tabstrc--recurs-tabbuff--259_1
dataread1;;tabstrc--recurs-tabbuff--259_1
datawrite1;>tabstrc--recurs-tabbuff_read--259_1
dataread1;;tabstrc--recurs-tabbuff_read--259_1

setreg2;:.


gotoif;>tabstrc--recurs-checkyes--259_1
goto;>tabstrc--recurs-checkno--259_1
null;;tabstrc--recurs-checkyes--259_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--259
setreg2;+
add
datawrite1;>tabstrc--adrbuff--259

setreg1;>tabstrc--adrbuff--259

datawrite1;>tabstrc--recurs-tabbuff--259_2
dataread1;;tabstrc--recurs-tabbuff--259_2
datawrite1;>tabstrc--recurs-tabbuff_read--259_2
dataread1;;tabstrc--recurs-tabbuff_read--259_2

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--259_2
goto;>tabstrc--recurs-checkno--259_2
null;;tabstrc--recurs-checkyes--259_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--259
setreg2;+
add
datawrite1;>tabstrc--adrbuff--259

setreg1;>tabstrc--adrbuff--259

datawrite1;>tabstrc--recurs-tabbuff--259_3
dataread1;;tabstrc--recurs-tabbuff--259_3
datawrite1;>tabstrc--recurs-tabbuff_read--259_3
dataread1;;tabstrc--recurs-tabbuff_read--259_3

setreg2;:x


gotoif;>tabstrc--recurs-checkyes--259_3
goto;>tabstrc--recurs-checkno--259_3
null;;tabstrc--recurs-checkyes--259_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--259
setreg2;+
add
datawrite1;>tabstrc--adrbuff--259

setreg1;>tabstrc--adrbuff--259

datawrite1;>tabstrc--recurs-tabbuff--259_4
dataread1;;tabstrc--recurs-tabbuff--259_4
datawrite1;>tabstrc--recurs-tabbuff_read--259_4
dataread1;;tabstrc--recurs-tabbuff_read--259_4

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--259_4
goto;>tabstrc--recurs-checkno--259_4
null;;tabstrc--recurs-checkyes--259_4
##set flag########
setreg1;>tabstrc--outbuff--259
datawrite1;>tabstrc--recurs-flag--259_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--259_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--259_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--259_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--259_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--259_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--259
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#return from subroutine.
s1pop1
gotoreg1
#label
null;;cmd_run_send_newline--label
#conditional goto
dataread1;>extflg
dataread2;>$true
gotoif;>goto--branch-266
goto;>goto--jumper-266
setreg1;>goto--jumper-266;goto--branch-266
goto;>cmd_run_send_newline_noext--label
null;;goto--jumper-266
#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;cmd_run_send_newline_noext--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_setup--label
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_char_exec--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--284
dataread1;;tabr--adrbuff--284
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_s_tmp
#conditional goto
dataread1;>run_tobuffer_flg
dataread2;>@1
gotoif;>goto--branch-286
goto;>goto--jumper-286
setreg1;>goto--jumper-286;goto--branch-286
goto;>run_send_doredir--label
null;;goto--jumper-286
#conditional set
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-287
goto;>goto--jumper-287
dataread1;>@1;goto--branch-287
datawrite1;>run_tobuffer_flg
null;;goto--jumper-287
#conditional return
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-288
goto;>goto--jumper-288
s1pop1;;goto--branch-288
gotoreg1
null;;goto--jumper-288
#get(1) (may be used with set, or asm code)
dataread1;>run_s_tmp
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #291
iowrite1;>vdi.cli.in#SSTNPL Source Line: '291' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_doredir--label
#buffer 2 head write
dataread1;>run_s_tmp
iowrite1;>buffer.2.write.head
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--299
dataread1;;tabr--adrbuff--299
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #300
iowrite1;>vdi.cli.in#SSTNPL Source Line: '300' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;pattern_print_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--304
dataread1;;tabr--adrbuff--304
iowrite1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;version--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-308
s1push1
goto;>splash--label
null;;goto--jumper-308
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#prline
fopwri1;:\s
fopwri1;:C
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:I
fopwri1;:n
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:p
fopwri1;:r
fopwri1;:e
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:\s
fopwri1;:v
fopwri1;:2
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;vdi--label
#val (used with set to change variable value during runtime.)
setreg1;10x1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #318
iowrite1;>vdi.cli.status#SSTNPL Source Line: '318' 
#Upward range iterator
dataread1;>@4
datawrite1;>vdi_iter
setreg1;>uiter-retpos-320;uiter-loopback-320
s1push1
goto;>vdi_buffiter--label
dataread1;>vdi_iter;uiter-retpos-320
setreg2;10x1
add
datawrite1;>vdi_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-320
gotoif;>uiter-loopback-320

#val (used with set to change variable value during runtime.)
setreg1;:\n
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #322
iowrite1;>vdi.cli.in#SSTNPL Source Line: '322' 
#goto 
goto;>vdi_outloop--label
#label
null;;vdi_outloop--label
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #329
ioread1;>vdi.cli.out#SSTNPL Source Line: '329' 
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>vdi_vdioutput_buffer
#conditional return
dataread1;>vdi_vdioutput_buffer
dataread2;>@0
gotoif;>goto--branch-332
goto;>goto--jumper-332
s1pop1;;goto--branch-332
gotoreg1
null;;goto--jumper-332
#Dump (character)
dataread1;>vdi_vdioutput_buffer
iowrite1;>io.ttywr
#goto 
goto;>vdi_outloop--label
#label
null;;drives--label
#prline
fopwri1;:A
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:B
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:R
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:H
fopwri1;:a
fopwri1;:r
fopwri1;:d
fopwri1;:w
fopwri1;:a
fopwri1;:r
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:a
fopwri1;:m
fopwri1;:d
fopwri1;:i
fopwri1;:s
fopwri1;:k
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;vdi_buffiter--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>vdi_iter
add
adddata1;10x1
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--345
dataread1;;tabr--adrbuff--345
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #346
iowrite1;>vdi.cli.in#SSTNPL Source Line: '346' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;help--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#bprinthead2n
fopset1;>buffer.2.write.head
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopset1;>io.ttywr
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;splash--label
#Set text colors
dataread1;>*+++0--
iowrite1;>io.textcolor
#print
fopwri1;:S
#Set text colors
dataread1;>*+++00-
iowrite1;>io.textcolor
#print
fopwri1;:B
#Set text colors
dataread1;>*+++-0-
iowrite1;>io.textcolor
#print
fopwri1;:T
#Set text colors
dataread1;>*+++-00
iowrite1;>io.textcolor
#print
fopwri1;:C
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#print
fopwri1;:V
#Set text colors
dataread1;>*+++0-0
iowrite1;>io.textcolor
#print
fopwri1;:M
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print
fopwri1;:-
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:D
fopwri1;:O
fopwri1;:S
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#return from subroutine.
s1pop1
gotoreg1
#label
null;;shutdown--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-381
s1push1
goto;>splash--label
null;;goto--jumper-381
#prline
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:u
fopwri1;:t
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:d
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:.
fopwri1;:.
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:d
fopwri1;:o
fopwri1;:n
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#stop (shutdown vm)
stop
#module include: line 389: comprompt as cp
includeas;comprompt,cp
#END OF FILE
