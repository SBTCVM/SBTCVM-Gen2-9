#SSTNPL COMPILER v0.3.0
#header
head-rname=command
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "apps/dos/command/command.stnp
null;0;sysbak
null;10x1;$true
null;10x1;@1
null;10x0;$false
null;+++---;*+++---
null;0;cmdflg
null;0;validflg
null;:A;drive
null;0+0---;*0+0---
null;10x0;@0
null;10x4;@4
null;10x3;@3
null;10x0;run_iter
null;:R;:R
null;:B;:B
null;:A;:A
null;:0;driveref
null;0;invalid_charcheck
null;0;extflg
null;0;extoffset
null;++0---;*++0---
null;10x2;@2
null;::;::
null;:0;:0
null;:1;:1
null;:2;:2
null;0;run_s_tmp
null;0;run_tobuffer_flg
null;:\s;:\s
null;0++---;*0++---
null;0;vdi_vdioutput_buffer
null;10x0;vdi_iter
null;+++0--;*+++0--
null;+++00-;*+++00-
null;+++-0-;*+++-0-
null;+++-00;*+++-00
null;+++--0;*+++--0
null;+++0-0;*+++0-0
#conditional goto
dataread1;>sysbak
dataread2;>$true
gotoif;>goto--branch-4
goto;>goto--jumper-4
setreg1;>goto--jumper-4;goto--branch-4
goto;>startup--label
null;;goto--jumper-4
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#label
null;;startup--label
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-14
goto;>goto--jumper-14
setreg1;>goto--jumper-14;goto--branch-14
s1push1
goto;>version--label
null;;goto--jumper-14
#val (used with set to change variable value during runtime.)
setreg1;10x1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>sysbak
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#prline
fopwri1;:T
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:?
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:\s
fopwri1;:R
fopwri1;:E
fopwri1;:A
fopwri1;:D
fopwri1;:Y
fopwri1;:.
fopwri1;:\n
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#buffer 2 reset
iowrite1;>buffer.2.reset
#goto 
goto;>main--label
#label
null;;main--label
#Set text colors
dataread1;>*0+0---
iowrite1;>io.textcolor
#Dump (character)
dataread1;>drive
iowrite1;>io.ttywr
#print
fopwri1;::
fopwri1;:\b
fopwri1;:>
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#goto (extra code stores away return address.)
setreg1;>goto--jumper-44
s1push1
goto;>cp.getentry--label
null;;goto--jumper-44
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validflg
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--50
null;;tabstrc--adrbuff--50
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--50
null;;tabstrc--outbuff--50
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--50

datawrite1;>tabstrc--recurs-tabbuff--50_1
dataread1;;tabstrc--recurs-tabbuff--50_1
datawrite1;>tabstrc--recurs-tabbuff_read--50_1
dataread1;;tabstrc--recurs-tabbuff_read--50_1

setreg2;:?


gotoif;>tabstrc--recurs-checkyes--50_1
goto;>tabstrc--recurs-checkno--50_1
null;;tabstrc--recurs-checkyes--50_1
##set flag########
setreg1;>tabstrc--outbuff--50
datawrite1;>tabstrc--recurs-flag--50_1
setreg1;+
datawrite1;;tabstrc--recurs-flag--50_1
#recursionskip endpoint
null;;tabstrc--recurs-checkno--50_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--50
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-52
goto;>goto--jumper-52
setreg1;>goto--jumper-52;goto--branch-52
s1push1
goto;>help--label
null;;goto--jumper-52
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-53
goto;>goto--jumper-53
dataread1;>@1;goto--branch-53
datawrite1;>validflg
null;;goto--jumper-53
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--54
null;;tabstrc--adrbuff--54
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--54
null;;tabstrc--outbuff--54
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--54

datawrite1;>tabstrc--recurs-tabbuff--54_1
dataread1;;tabstrc--recurs-tabbuff--54_1
datawrite1;>tabstrc--recurs-tabbuff_read--54_1
dataread1;;tabstrc--recurs-tabbuff_read--54_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--54_1
goto;>tabstrc--recurs-checkno--54_1
null;;tabstrc--recurs-checkyes--54_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--54
setreg2;+
add
datawrite1;>tabstrc--adrbuff--54

setreg1;>tabstrc--adrbuff--54

datawrite1;>tabstrc--recurs-tabbuff--54_2
dataread1;;tabstrc--recurs-tabbuff--54_2
datawrite1;>tabstrc--recurs-tabbuff_read--54_2
dataread1;;tabstrc--recurs-tabbuff_read--54_2

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--54_2
goto;>tabstrc--recurs-checkno--54_2
null;;tabstrc--recurs-checkyes--54_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--54
setreg2;+
add
datawrite1;>tabstrc--adrbuff--54

setreg1;>tabstrc--adrbuff--54

datawrite1;>tabstrc--recurs-tabbuff--54_3
dataread1;;tabstrc--recurs-tabbuff--54_3
datawrite1;>tabstrc--recurs-tabbuff_read--54_3
dataread1;;tabstrc--recurs-tabbuff_read--54_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--54_3
goto;>tabstrc--recurs-checkno--54_3
null;;tabstrc--recurs-checkyes--54_3
##set flag########
setreg1;>tabstrc--outbuff--54
datawrite1;>tabstrc--recurs-flag--54_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--54_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--54_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--54_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--54_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--54
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-56
goto;>goto--jumper-56
setreg1;>goto--jumper-56;goto--branch-56
s1push1
goto;>vdi--label
null;;goto--jumper-56
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-57
goto;>goto--jumper-57
dataread1;>@1;goto--branch-57
datawrite1;>validflg
null;;goto--jumper-57
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--58
null;;tabstrc--adrbuff--58
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--58
null;;tabstrc--outbuff--58
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--58

datawrite1;>tabstrc--recurs-tabbuff--58_1
dataread1;;tabstrc--recurs-tabbuff--58_1
datawrite1;>tabstrc--recurs-tabbuff_read--58_1
dataread1;;tabstrc--recurs-tabbuff_read--58_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--58_1
goto;>tabstrc--recurs-checkno--58_1
null;;tabstrc--recurs-checkyes--58_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--58
setreg2;+
add
datawrite1;>tabstrc--adrbuff--58

setreg1;>tabstrc--adrbuff--58

datawrite1;>tabstrc--recurs-tabbuff--58_2
dataread1;;tabstrc--recurs-tabbuff--58_2
datawrite1;>tabstrc--recurs-tabbuff_read--58_2
dataread1;;tabstrc--recurs-tabbuff_read--58_2

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--58_2
goto;>tabstrc--recurs-checkno--58_2
null;;tabstrc--recurs-checkyes--58_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--58
setreg2;+
add
datawrite1;>tabstrc--adrbuff--58

setreg1;>tabstrc--adrbuff--58

datawrite1;>tabstrc--recurs-tabbuff--58_3
dataread1;;tabstrc--recurs-tabbuff--58_3
datawrite1;>tabstrc--recurs-tabbuff_read--58_3
dataread1;;tabstrc--recurs-tabbuff_read--58_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--58_3
goto;>tabstrc--recurs-checkno--58_3
null;;tabstrc--recurs-checkyes--58_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--58
setreg2;+
add
datawrite1;>tabstrc--adrbuff--58

setreg1;>tabstrc--adrbuff--58

datawrite1;>tabstrc--recurs-tabbuff--58_4
dataread1;;tabstrc--recurs-tabbuff--58_4
datawrite1;>tabstrc--recurs-tabbuff_read--58_4
dataread1;;tabstrc--recurs-tabbuff_read--58_4

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--58_4
goto;>tabstrc--recurs-checkno--58_4
null;;tabstrc--recurs-checkyes--58_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--58
setreg2;+
add
datawrite1;>tabstrc--adrbuff--58

setreg1;>tabstrc--adrbuff--58

datawrite1;>tabstrc--recurs-tabbuff--58_5
dataread1;;tabstrc--recurs-tabbuff--58_5
datawrite1;>tabstrc--recurs-tabbuff_read--58_5
dataread1;;tabstrc--recurs-tabbuff_read--58_5

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--58_5
goto;>tabstrc--recurs-checkno--58_5
null;;tabstrc--recurs-checkyes--58_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--58
setreg2;+
add
datawrite1;>tabstrc--adrbuff--58

setreg1;>tabstrc--adrbuff--58

datawrite1;>tabstrc--recurs-tabbuff--58_6
dataread1;;tabstrc--recurs-tabbuff--58_6
datawrite1;>tabstrc--recurs-tabbuff_read--58_6
dataread1;;tabstrc--recurs-tabbuff_read--58_6

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--58_6
goto;>tabstrc--recurs-checkno--58_6
null;;tabstrc--recurs-checkyes--58_6
##set flag########
setreg1;>tabstrc--outbuff--58
datawrite1;>tabstrc--recurs-flag--58_6
setreg1;+
datawrite1;;tabstrc--recurs-flag--58_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--58_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--58_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--58_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--58_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--58_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--58_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--58
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-60
goto;>goto--jumper-60
setreg1;>goto--jumper-60;goto--branch-60
s1push1
goto;>drives--label
null;;goto--jumper-60
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-61
goto;>goto--jumper-61
dataread1;>@1;goto--branch-61
datawrite1;>validflg
null;;goto--jumper-61
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--62
null;;tabstrc--adrbuff--62
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--62
null;;tabstrc--outbuff--62
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--62

datawrite1;>tabstrc--recurs-tabbuff--62_1
dataread1;;tabstrc--recurs-tabbuff--62_1
datawrite1;>tabstrc--recurs-tabbuff_read--62_1
dataread1;;tabstrc--recurs-tabbuff_read--62_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--62_1
goto;>tabstrc--recurs-checkno--62_1
null;;tabstrc--recurs-checkyes--62_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--62
setreg2;+
add
datawrite1;>tabstrc--adrbuff--62

setreg1;>tabstrc--adrbuff--62

datawrite1;>tabstrc--recurs-tabbuff--62_2
dataread1;;tabstrc--recurs-tabbuff--62_2
datawrite1;>tabstrc--recurs-tabbuff_read--62_2
dataread1;;tabstrc--recurs-tabbuff_read--62_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--62_2
goto;>tabstrc--recurs-checkno--62_2
null;;tabstrc--recurs-checkyes--62_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--62
setreg2;+
add
datawrite1;>tabstrc--adrbuff--62

setreg1;>tabstrc--adrbuff--62

datawrite1;>tabstrc--recurs-tabbuff--62_3
dataread1;;tabstrc--recurs-tabbuff--62_3
datawrite1;>tabstrc--recurs-tabbuff_read--62_3
dataread1;;tabstrc--recurs-tabbuff_read--62_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--62_3
goto;>tabstrc--recurs-checkno--62_3
null;;tabstrc--recurs-checkyes--62_3
##set flag########
setreg1;>tabstrc--outbuff--62
datawrite1;>tabstrc--recurs-flag--62_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--62_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--62_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--62_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--62_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--62
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-64
goto;>goto--jumper-64
setreg1;>goto--jumper-64;goto--branch-64
s1push1
goto;>version--label
null;;goto--jumper-64
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-65
goto;>goto--jumper-65
dataread1;>@1;goto--branch-65
datawrite1;>validflg
null;;goto--jumper-65
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--66
null;;tabstrc--adrbuff--66
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--66
null;;tabstrc--outbuff--66
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_1
dataread1;;tabstrc--recurs-tabbuff--66_1
datawrite1;>tabstrc--recurs-tabbuff_read--66_1
dataread1;;tabstrc--recurs-tabbuff_read--66_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--66_1
goto;>tabstrc--recurs-checkno--66_1
null;;tabstrc--recurs-checkyes--66_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--66
setreg2;+
add
datawrite1;>tabstrc--adrbuff--66

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_2
dataread1;;tabstrc--recurs-tabbuff--66_2
datawrite1;>tabstrc--recurs-tabbuff_read--66_2
dataread1;;tabstrc--recurs-tabbuff_read--66_2

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--66_2
goto;>tabstrc--recurs-checkno--66_2
null;;tabstrc--recurs-checkyes--66_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--66
setreg2;+
add
datawrite1;>tabstrc--adrbuff--66

setreg1;>tabstrc--adrbuff--66

datawrite1;>tabstrc--recurs-tabbuff--66_3
dataread1;;tabstrc--recurs-tabbuff--66_3
datawrite1;>tabstrc--recurs-tabbuff_read--66_3
dataread1;;tabstrc--recurs-tabbuff_read--66_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--66_3
goto;>tabstrc--recurs-checkno--66_3
null;;tabstrc--recurs-checkyes--66_3
##set flag########
setreg1;>tabstrc--outbuff--66
datawrite1;>tabstrc--recurs-flag--66_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--66_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--66_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--66
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-68
goto;>goto--jumper-68
setreg1;>goto--jumper-68;goto--branch-68
s1push1
goto;>directory_list--label
null;;goto--jumper-68
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-69
goto;>goto--jumper-69
dataread1;>@1;goto--branch-69
datawrite1;>validflg
null;;goto--jumper-69
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--70
null;;tabstrc--adrbuff--70
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--70
null;;tabstrc--outbuff--70
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_1
dataread1;;tabstrc--recurs-tabbuff--70_1
datawrite1;>tabstrc--recurs-tabbuff_read--70_1
dataread1;;tabstrc--recurs-tabbuff_read--70_1

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--70_1
goto;>tabstrc--recurs-checkno--70_1
null;;tabstrc--recurs-checkyes--70_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_2
dataread1;;tabstrc--recurs-tabbuff--70_2
datawrite1;>tabstrc--recurs-tabbuff_read--70_2
dataread1;;tabstrc--recurs-tabbuff_read--70_2

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--70_2
goto;>tabstrc--recurs-checkno--70_2
null;;tabstrc--recurs-checkyes--70_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_3
dataread1;;tabstrc--recurs-tabbuff--70_3
datawrite1;>tabstrc--recurs-tabbuff_read--70_3
dataread1;;tabstrc--recurs-tabbuff_read--70_3

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--70_3
goto;>tabstrc--recurs-checkno--70_3
null;;tabstrc--recurs-checkyes--70_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_4
dataread1;;tabstrc--recurs-tabbuff--70_4
datawrite1;>tabstrc--recurs-tabbuff_read--70_4
dataread1;;tabstrc--recurs-tabbuff_read--70_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--70_4
goto;>tabstrc--recurs-checkno--70_4
null;;tabstrc--recurs-checkyes--70_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_5
dataread1;;tabstrc--recurs-tabbuff--70_5
datawrite1;>tabstrc--recurs-tabbuff_read--70_5
dataread1;;tabstrc--recurs-tabbuff_read--70_5

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--70_5
goto;>tabstrc--recurs-checkno--70_5
null;;tabstrc--recurs-checkyes--70_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_6
dataread1;;tabstrc--recurs-tabbuff--70_6
datawrite1;>tabstrc--recurs-tabbuff_read--70_6
dataread1;;tabstrc--recurs-tabbuff_read--70_6

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--70_6
goto;>tabstrc--recurs-checkno--70_6
null;;tabstrc--recurs-checkyes--70_6
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_7
dataread1;;tabstrc--recurs-tabbuff--70_7
datawrite1;>tabstrc--recurs-tabbuff_read--70_7
dataread1;;tabstrc--recurs-tabbuff_read--70_7

setreg2;:w


gotoif;>tabstrc--recurs-checkyes--70_7
goto;>tabstrc--recurs-checkno--70_7
null;;tabstrc--recurs-checkyes--70_7
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--70
setreg2;+
add
datawrite1;>tabstrc--adrbuff--70

setreg1;>tabstrc--adrbuff--70

datawrite1;>tabstrc--recurs-tabbuff--70_8
dataread1;;tabstrc--recurs-tabbuff--70_8
datawrite1;>tabstrc--recurs-tabbuff_read--70_8
dataread1;;tabstrc--recurs-tabbuff_read--70_8

setreg2;:n


gotoif;>tabstrc--recurs-checkyes--70_8
goto;>tabstrc--recurs-checkno--70_8
null;;tabstrc--recurs-checkyes--70_8
##set flag########
setreg1;>tabstrc--outbuff--70
datawrite1;>tabstrc--recurs-flag--70_8
setreg1;+
datawrite1;;tabstrc--recurs-flag--70_8
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_8
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_7
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--70_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--70
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-72
goto;>goto--jumper-72
setreg1;>goto--jumper-72;goto--branch-72
s1push1
goto;>shutdown--label
null;;goto--jumper-72
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-73
goto;>goto--jumper-73
dataread1;>@1;goto--branch-73
datawrite1;>validflg
null;;goto--jumper-73
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--76
null;;tabstrc--adrbuff--76
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--76
null;;tabstrc--outbuff--76
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_1
dataread1;;tabstrc--recurs-tabbuff--76_1
datawrite1;>tabstrc--recurs-tabbuff_read--76_1
dataread1;;tabstrc--recurs-tabbuff_read--76_1

setreg2;:a


gotoif;>tabstrc--recurs-checkyes--76_1
goto;>tabstrc--recurs-checkno--76_1
null;;tabstrc--recurs-checkyes--76_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_2
dataread1;;tabstrc--recurs-tabbuff--76_2
datawrite1;>tabstrc--recurs-tabbuff_read--76_2
dataread1;;tabstrc--recurs-tabbuff_read--76_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--76_2
goto;>tabstrc--recurs-checkno--76_2
null;;tabstrc--recurs-checkyes--76_2
##set flag########
setreg1;>tabstrc--outbuff--76
datawrite1;>tabstrc--recurs-flag--76_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--76_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--76
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-78
goto;>goto--jumper-78
setreg1;>goto--jumper-78;goto--branch-78
s1push1
goto;>driveA--label
null;;goto--jumper-78
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-79
goto;>goto--jumper-79
dataread1;>@1;goto--branch-79
datawrite1;>validflg
null;;goto--jumper-79
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--80
null;;tabstrc--adrbuff--80
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--80
null;;tabstrc--outbuff--80
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--80

datawrite1;>tabstrc--recurs-tabbuff--80_1
dataread1;;tabstrc--recurs-tabbuff--80_1
datawrite1;>tabstrc--recurs-tabbuff_read--80_1
dataread1;;tabstrc--recurs-tabbuff_read--80_1

setreg2;:A


gotoif;>tabstrc--recurs-checkyes--80_1
goto;>tabstrc--recurs-checkno--80_1
null;;tabstrc--recurs-checkyes--80_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--80
setreg2;+
add
datawrite1;>tabstrc--adrbuff--80

setreg1;>tabstrc--adrbuff--80

datawrite1;>tabstrc--recurs-tabbuff--80_2
dataread1;;tabstrc--recurs-tabbuff--80_2
datawrite1;>tabstrc--recurs-tabbuff_read--80_2
dataread1;;tabstrc--recurs-tabbuff_read--80_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--80_2
goto;>tabstrc--recurs-checkno--80_2
null;;tabstrc--recurs-checkyes--80_2
##set flag########
setreg1;>tabstrc--outbuff--80
datawrite1;>tabstrc--recurs-flag--80_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--80_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--80_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--80_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--80
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-82
goto;>goto--jumper-82
setreg1;>goto--jumper-82;goto--branch-82
s1push1
goto;>driveA--label
null;;goto--jumper-82
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-83
goto;>goto--jumper-83
dataread1;>@1;goto--branch-83
datawrite1;>validflg
null;;goto--jumper-83
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--85
null;;tabstrc--adrbuff--85
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--85
null;;tabstrc--outbuff--85
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--85

datawrite1;>tabstrc--recurs-tabbuff--85_1
dataread1;;tabstrc--recurs-tabbuff--85_1
datawrite1;>tabstrc--recurs-tabbuff_read--85_1
dataread1;;tabstrc--recurs-tabbuff_read--85_1

setreg2;:b


gotoif;>tabstrc--recurs-checkyes--85_1
goto;>tabstrc--recurs-checkno--85_1
null;;tabstrc--recurs-checkyes--85_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--85
setreg2;+
add
datawrite1;>tabstrc--adrbuff--85

setreg1;>tabstrc--adrbuff--85

datawrite1;>tabstrc--recurs-tabbuff--85_2
dataread1;;tabstrc--recurs-tabbuff--85_2
datawrite1;>tabstrc--recurs-tabbuff_read--85_2
dataread1;;tabstrc--recurs-tabbuff_read--85_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--85_2
goto;>tabstrc--recurs-checkno--85_2
null;;tabstrc--recurs-checkyes--85_2
##set flag########
setreg1;>tabstrc--outbuff--85
datawrite1;>tabstrc--recurs-flag--85_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--85_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--85_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--85_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--85
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-87
goto;>goto--jumper-87
setreg1;>goto--jumper-87;goto--branch-87
s1push1
goto;>driveB--label
null;;goto--jumper-87
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-88
goto;>goto--jumper-88
dataread1;>@1;goto--branch-88
datawrite1;>validflg
null;;goto--jumper-88
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--89
null;;tabstrc--adrbuff--89
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--89
null;;tabstrc--outbuff--89
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--89

datawrite1;>tabstrc--recurs-tabbuff--89_1
dataread1;;tabstrc--recurs-tabbuff--89_1
datawrite1;>tabstrc--recurs-tabbuff_read--89_1
dataread1;;tabstrc--recurs-tabbuff_read--89_1

setreg2;:B


gotoif;>tabstrc--recurs-checkyes--89_1
goto;>tabstrc--recurs-checkno--89_1
null;;tabstrc--recurs-checkyes--89_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--89
setreg2;+
add
datawrite1;>tabstrc--adrbuff--89

setreg1;>tabstrc--adrbuff--89

datawrite1;>tabstrc--recurs-tabbuff--89_2
dataread1;;tabstrc--recurs-tabbuff--89_2
datawrite1;>tabstrc--recurs-tabbuff_read--89_2
dataread1;;tabstrc--recurs-tabbuff_read--89_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--89_2
goto;>tabstrc--recurs-checkno--89_2
null;;tabstrc--recurs-checkyes--89_2
##set flag########
setreg1;>tabstrc--outbuff--89
datawrite1;>tabstrc--recurs-flag--89_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--89_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--89_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--89_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--89
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-91
goto;>goto--jumper-91
setreg1;>goto--jumper-91;goto--branch-91
s1push1
goto;>driveB--label
null;;goto--jumper-91
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-92
goto;>goto--jumper-92
dataread1;>@1;goto--branch-92
datawrite1;>validflg
null;;goto--jumper-92
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--94
null;;tabstrc--adrbuff--94
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--94
null;;tabstrc--outbuff--94
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--94

datawrite1;>tabstrc--recurs-tabbuff--94_1
dataread1;;tabstrc--recurs-tabbuff--94_1
datawrite1;>tabstrc--recurs-tabbuff_read--94_1
dataread1;;tabstrc--recurs-tabbuff_read--94_1

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--94_1
goto;>tabstrc--recurs-checkno--94_1
null;;tabstrc--recurs-checkyes--94_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--94
setreg2;+
add
datawrite1;>tabstrc--adrbuff--94

setreg1;>tabstrc--adrbuff--94

datawrite1;>tabstrc--recurs-tabbuff--94_2
dataread1;;tabstrc--recurs-tabbuff--94_2
datawrite1;>tabstrc--recurs-tabbuff_read--94_2
dataread1;;tabstrc--recurs-tabbuff_read--94_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--94_2
goto;>tabstrc--recurs-checkno--94_2
null;;tabstrc--recurs-checkyes--94_2
##set flag########
setreg1;>tabstrc--outbuff--94
datawrite1;>tabstrc--recurs-flag--94_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--94_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--94_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--94_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--94
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-96
goto;>goto--jumper-96
setreg1;>goto--jumper-96;goto--branch-96
s1push1
goto;>driveR--label
null;;goto--jumper-96
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-97
goto;>goto--jumper-97
dataread1;>@1;goto--branch-97
datawrite1;>validflg
null;;goto--jumper-97
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--98
null;;tabstrc--adrbuff--98
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--98
null;;tabstrc--outbuff--98
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--98

datawrite1;>tabstrc--recurs-tabbuff--98_1
dataread1;;tabstrc--recurs-tabbuff--98_1
datawrite1;>tabstrc--recurs-tabbuff_read--98_1
dataread1;;tabstrc--recurs-tabbuff_read--98_1

setreg2;:R


gotoif;>tabstrc--recurs-checkyes--98_1
goto;>tabstrc--recurs-checkno--98_1
null;;tabstrc--recurs-checkyes--98_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--98
setreg2;+
add
datawrite1;>tabstrc--adrbuff--98

setreg1;>tabstrc--adrbuff--98

datawrite1;>tabstrc--recurs-tabbuff--98_2
dataread1;;tabstrc--recurs-tabbuff--98_2
datawrite1;>tabstrc--recurs-tabbuff_read--98_2
dataread1;;tabstrc--recurs-tabbuff_read--98_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--98_2
goto;>tabstrc--recurs-checkno--98_2
null;;tabstrc--recurs-checkyes--98_2
##set flag########
setreg1;>tabstrc--outbuff--98
datawrite1;>tabstrc--recurs-flag--98_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--98_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--98_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--98_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--98
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-100
goto;>goto--jumper-100
setreg1;>goto--jumper-100;goto--branch-100
s1push1
goto;>driveR--label
null;;goto--jumper-100
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-101
goto;>goto--jumper-101
dataread1;>@1;goto--branch-101
datawrite1;>validflg
null;;goto--jumper-101
#conditional subroutine goto
dataread1;>validflg
dataread2;>@0
gotoif;>goto--branch-103
goto;>goto--jumper-103
setreg1;>goto--jumper-103;goto--branch-103
s1push1
goto;>invalid--label
null;;goto--jumper-103
#goto 
goto;>main--label
#label
null;;driveA--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-111
goto;>goto--jumper-111
setreg1;>goto--jumper-111;goto--branch-111
s1push1
goto;>extcheck--label
null;;goto--jumper-111
#val (used with set to change variable value during runtime.)
setreg1;:A
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#conditional return
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--branch-114
goto;>goto--jumper-114
s1pop1;;goto--branch-114
gotoreg1
null;;goto--jumper-114
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-117
s1push1
goto;>run_send_setup--label
null;;goto--jumper-117
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-118;uiter-loopback-118
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-118
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-118
gotoif;>uiter-loopback-118

#goto (extra code stores away return address.)
setreg1;>goto--jumper-119
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-119
#goto (extra code stores away return address.)
setreg1;>goto--jumper-122
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-122
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveB--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-128
goto;>goto--jumper-128
setreg1;>goto--jumper-128;goto--branch-128
s1push1
goto;>extcheck--label
null;;goto--jumper-128
#val (used with set to change variable value during runtime.)
setreg1;:B
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#conditional return
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--branch-131
goto;>goto--jumper-131
s1pop1;;goto--branch-131
gotoreg1
null;;goto--jumper-131
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-134
s1push1
goto;>run_send_setup--label
null;;goto--jumper-134
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-135;uiter-loopback-135
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-135
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-135
gotoif;>uiter-loopback-135

#goto (extra code stores away return address.)
setreg1;>goto--jumper-136
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-136
#goto (extra code stores away return address.)
setreg1;>goto--jumper-139
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-139
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveR--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-146
goto;>goto--jumper-146
setreg1;>goto--jumper-146;goto--branch-146
s1push1
goto;>extcheck--label
null;;goto--jumper-146
#val (used with set to change variable value during runtime.)
setreg1;:R
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#conditional return
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--branch-149
goto;>goto--jumper-149
s1pop1;;goto--branch-149
gotoreg1
null;;goto--jumper-149
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-152
s1push1
goto;>run_send_setup--label
null;;goto--jumper-152
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-153;uiter-loopback-153
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-153
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-153
gotoif;>uiter-loopback-153

#goto (extra code stores away return address.)
setreg1;>goto--jumper-154
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-154
#goto (extra code stores away return address.)
setreg1;>goto--jumper-157
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-157
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list--label
#conditional subroutine goto
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-162
goto;>goto--jumper-162
setreg1;>goto--jumper-162;goto--branch-162
s1push1
goto;>directory_list_R--label
null;;goto--jumper-162
#conditional subroutine goto
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-163
goto;>goto--jumper-163
setreg1;>goto--jumper-163;goto--branch-163
s1push1
goto;>directory_list_B--label
null;;goto--jumper-163
#conditional subroutine goto
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-164
goto;>goto--jumper-164
setreg1;>goto--jumper-164;goto--branch-164
s1push1
goto;>directory_list_A--label
null;;goto--jumper-164
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_A--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:A
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-169;uiter-loopback-169
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-169
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-169
gotoif;>uiter-loopback-169

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-172;uiter-loopback-172
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-172
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-172
gotoif;>uiter-loopback-172

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-174
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-174
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_B--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:B
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-179;uiter-loopback-179
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-179
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-179
gotoif;>uiter-loopback-179

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-182;uiter-loopback-182
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-182
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-182
gotoif;>uiter-loopback-182

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-184
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-184
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_R--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-189;uiter-loopback-189
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-189
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-189
gotoif;>uiter-loopback-189

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-192;uiter-loopback-192
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-192
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-192
gotoif;>uiter-loopback-192

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-194
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-194
#return from subroutine.
s1pop1
gotoreg1
#label
null;;invalid--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-203
goto;>goto--jumper-203
setreg1;>goto--jumper-203;goto--branch-203
s1push1
goto;>extcheck--label
null;;goto--jumper-203
#Set text colors
dataread1;>*++0---
iowrite1;>io.textcolor
#conditional goto
dataread1;>cp.size
dataread2;>@2
gotoifless;>goto--branch-205
goto;>goto--jumper-205
setreg1;>goto--jumper-205;goto--branch-205
goto;>run_command--label
null;;goto--jumper-205
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>@1
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--208
dataread1;;tabr--adrbuff--208
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>invalid_charcheck
#conditional goto
dataread1;>invalid_charcheck
dataread2;>::
gotoif;>goto--jumper-210
goto;>goto--branch-210
setreg1;>goto--jumper-210;goto--branch-210
goto;>run_command--label
null;;goto--jumper-210
#prline
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:N
fopwri1;:o
fopwri1;:t
fopwri1;:\s
fopwri1;:V
fopwri1;:a
fopwri1;:l
fopwri1;:i
fopwri1;:d
fopwri1;:.
fopwri1;:\s
fopwri1;:s
fopwri1;:e
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:d
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:s
fopwri1;:'
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_command--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopset1;>io.ttywr
#conditional set
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-218
goto;>goto--jumper-218
dataread1;>:0;goto--branch-218
datawrite1;>driveref
null;;goto--jumper-218
#conditional set
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-219
goto;>goto--jumper-219
dataread1;>:1;goto--branch-219
datawrite1;>driveref
null;;goto--jumper-219
#conditional set
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-220
goto;>goto--jumper-220
dataread1;>:2;goto--branch-220
datawrite1;>driveref
null;;goto--jumper-220
#get(1) (may be used with set, or asm code)
dataread1;>driveref
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #222
iowrite1;>vdi.cli.in#SSTNPL Source Line: '222' 
#vdin
fopset1;>vdi.cli.in
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-224
s1push1
goto;>run_send_setup--label
null;;goto--jumper-224
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-225;uiter-loopback-225
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-225
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-225
gotoif;>uiter-loopback-225

#goto (extra code stores away return address.)
setreg1;>goto--jumper-226
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-226
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-230
s1push1
goto;>run_send_setup--label
null;;goto--jumper-230
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-231;uiter-loopback-231
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-231
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-231
gotoif;>uiter-loopback-231

#goto (extra code stores away return address.)
setreg1;>goto--jumper-232
s1push1
goto;>cmd_run_send_newline--label
null;;goto--jumper-232
#goto (extra code stores away return address.)
setreg1;>goto--jumper-234
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-234
#return from subroutine.
s1pop1
gotoreg1
#label
null;;extcheck--label
#return from subroutine.
s1pop1
gotoreg1
#subtract (2op math)
dataread1;>cp.size
dataread2;>@4
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extoffset
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>extoffset
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--244
null;;tabstrc--adrbuff--244
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--244
null;;tabstrc--outbuff--244
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--244

datawrite1;>tabstrc--recurs-tabbuff--244_1
dataread1;;tabstrc--recurs-tabbuff--244_1
datawrite1;>tabstrc--recurs-tabbuff_read--244_1
dataread1;;tabstrc--recurs-tabbuff_read--244_1

setreg2;:.


gotoif;>tabstrc--recurs-checkyes--244_1
goto;>tabstrc--recurs-checkno--244_1
null;;tabstrc--recurs-checkyes--244_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--244
setreg2;+
add
datawrite1;>tabstrc--adrbuff--244

setreg1;>tabstrc--adrbuff--244

datawrite1;>tabstrc--recurs-tabbuff--244_2
dataread1;;tabstrc--recurs-tabbuff--244_2
datawrite1;>tabstrc--recurs-tabbuff_read--244_2
dataread1;;tabstrc--recurs-tabbuff_read--244_2

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--244_2
goto;>tabstrc--recurs-checkno--244_2
null;;tabstrc--recurs-checkyes--244_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--244
setreg2;+
add
datawrite1;>tabstrc--adrbuff--244

setreg1;>tabstrc--adrbuff--244

datawrite1;>tabstrc--recurs-tabbuff--244_3
dataread1;;tabstrc--recurs-tabbuff--244_3
datawrite1;>tabstrc--recurs-tabbuff_read--244_3
dataread1;;tabstrc--recurs-tabbuff_read--244_3

setreg2;:x


gotoif;>tabstrc--recurs-checkyes--244_3
goto;>tabstrc--recurs-checkno--244_3
null;;tabstrc--recurs-checkyes--244_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--244
setreg2;+
add
datawrite1;>tabstrc--adrbuff--244

setreg1;>tabstrc--adrbuff--244

datawrite1;>tabstrc--recurs-tabbuff--244_4
dataread1;;tabstrc--recurs-tabbuff--244_4
datawrite1;>tabstrc--recurs-tabbuff_read--244_4
dataread1;;tabstrc--recurs-tabbuff_read--244_4

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--244_4
goto;>tabstrc--recurs-checkno--244_4
null;;tabstrc--recurs-checkyes--244_4
##set flag########
setreg1;>tabstrc--outbuff--244
datawrite1;>tabstrc--recurs-flag--244_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--244_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--244_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--244_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--244_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--244_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--244
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#return from subroutine.
s1pop1
gotoreg1
#label
null;;cmd_run_send_newline--label
#conditional goto
dataread1;>extflg
dataread2;>$true
gotoif;>goto--branch-251
goto;>goto--jumper-251
setreg1;>goto--jumper-251;goto--branch-251
goto;>cmd_run_send_newline_noext--label
null;;goto--jumper-251
#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;cmd_run_send_newline_noext--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_setup--label
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_char_exec--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--269
dataread1;;tabr--adrbuff--269
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_s_tmp
#conditional goto
dataread1;>run_tobuffer_flg
dataread2;>@1
gotoif;>goto--branch-271
goto;>goto--jumper-271
setreg1;>goto--jumper-271;goto--branch-271
goto;>run_send_doredir--label
null;;goto--jumper-271
#conditional set
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-272
goto;>goto--jumper-272
dataread1;>@1;goto--branch-272
datawrite1;>run_tobuffer_flg
null;;goto--jumper-272
#conditional return
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-273
goto;>goto--jumper-273
s1pop1;;goto--branch-273
gotoreg1
null;;goto--jumper-273
#get(1) (may be used with set, or asm code)
dataread1;>run_s_tmp
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #276
iowrite1;>vdi.cli.in#SSTNPL Source Line: '276' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_doredir--label
#buffer 2 head write
dataread1;>run_s_tmp
iowrite1;>buffer.2.write.head
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--284
dataread1;;tabr--adrbuff--284
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #285
iowrite1;>vdi.cli.in#SSTNPL Source Line: '285' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;pattern_print_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--289
dataread1;;tabr--adrbuff--289
iowrite1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;version--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-293
s1push1
goto;>splash--label
null;;goto--jumper-293
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#prline
fopwri1;:\s
fopwri1;:C
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:I
fopwri1;:n
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:p
fopwri1;:r
fopwri1;:e
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:\s
fopwri1;:v
fopwri1;:2
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;vdi--label
#val (used with set to change variable value during runtime.)
setreg1;10x1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #303
iowrite1;>vdi.cli.status#SSTNPL Source Line: '303' 
#Upward range iterator
dataread1;>@4
datawrite1;>vdi_iter
setreg1;>uiter-retpos-305;uiter-loopback-305
s1push1
goto;>vdi_buffiter--label
dataread1;>vdi_iter;uiter-retpos-305
setreg2;10x1
add
datawrite1;>vdi_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-305
gotoif;>uiter-loopback-305

#val (used with set to change variable value during runtime.)
setreg1;:\n
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #307
iowrite1;>vdi.cli.in#SSTNPL Source Line: '307' 
#goto 
goto;>vdi_outloop--label
#label
null;;vdi_outloop--label
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #314
ioread1;>vdi.cli.out#SSTNPL Source Line: '314' 
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>vdi_vdioutput_buffer
#conditional return
dataread1;>vdi_vdioutput_buffer
dataread2;>@0
gotoif;>goto--branch-317
goto;>goto--jumper-317
s1pop1;;goto--branch-317
gotoreg1
null;;goto--jumper-317
#Dump (character)
dataread1;>vdi_vdioutput_buffer
iowrite1;>io.ttywr
#goto 
goto;>vdi_outloop--label
#label
null;;drives--label
#prline
fopwri1;:A
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:B
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:R
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:H
fopwri1;:a
fopwri1;:r
fopwri1;:d
fopwri1;:w
fopwri1;:a
fopwri1;:r
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:a
fopwri1;:m
fopwri1;:d
fopwri1;:i
fopwri1;:s
fopwri1;:k
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;vdi_buffiter--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>vdi_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--330
dataread1;;tabr--adrbuff--330
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #331
iowrite1;>vdi.cli.in#SSTNPL Source Line: '331' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;help--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#bprinthead2n
fopset1;>buffer.2.write.head
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopset1;>io.ttywr
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;splash--label
#Set text colors
dataread1;>*+++0--
iowrite1;>io.textcolor
#print
fopwri1;:S
#Set text colors
dataread1;>*+++00-
iowrite1;>io.textcolor
#print
fopwri1;:B
#Set text colors
dataread1;>*+++-0-
iowrite1;>io.textcolor
#print
fopwri1;:T
#Set text colors
dataread1;>*+++-00
iowrite1;>io.textcolor
#print
fopwri1;:C
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#print
fopwri1;:V
#Set text colors
dataread1;>*+++0-0
iowrite1;>io.textcolor
#print
fopwri1;:M
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print
fopwri1;:-
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:D
fopwri1;:O
fopwri1;:S
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#return from subroutine.
s1pop1
gotoreg1
#label
null;;shutdown--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-366
s1push1
goto;>splash--label
null;;goto--jumper-366
#prline
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:u
fopwri1;:t
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:d
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:.
fopwri1;:.
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:d
fopwri1;:o
fopwri1;:n
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#stop (shutdown vm)
stop
#module include: line 374: comprompt as cp
includeas;comprompt,cp
#END OF FILE
