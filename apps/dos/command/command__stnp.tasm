#SSTNPL COMPILER v0.4.0
#header
head-rname=command
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "apps/dos/command/command.stnp
null;0;sysbak
null;10x1;$true
null;10x1;@1
null;10x0;$false
null;+++---;*+++---
null;0;cmdflg
null;0;validflg
null;:A;drive
null;0+0---;*0+0---
null;10x0;@0
null;10x4;@4
null;10x3;@3
null;10x0;run_iter
null;:R;:R
null;:B;:B
null;:A;:A
null;:0;driveref
null;0;invalid_charcheck
null;0;extflg
null;0;extoffset
null;++0---;*++0---
null;10x2;@2
null;::;::
null;:0;:0
null;:1;:1
null;:2;:2
null;0;run_s_tmp
null;0;run_tobuffer_flg
null;:\s;:\s
null;0++---;*0++---
null;0;vdi_vdioutput_buffer
null;10x0;vdi_iter
null;+++0--;*+++0--
null;+++00-;*+++00-
null;+++-0-;*+++-0-
null;+++-00;*+++-00
null;+++--0;*+++--0
null;+++0-0;*+++0-0
#conditional goto
dataread1;>sysbak
dataread2;>$true
gotoif;>goto--branch-4
goto;>goto--jumper-4
setreg1;>goto--jumper-4;goto--branch-4
goto;>startup--label
zerosize;;goto--jumper-4
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#label
zerosize;;startup--label
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-14
goto;>goto--jumper-14
setreg1;>goto--jumper-14;goto--branch-14
s1push1
goto;>version--label
zerosize;;goto--jumper-14
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-15
goto;>goto--jumper-15
setreg1;>goto--jumper-15;goto--branch-15
s1push1
goto;>help_ready_splash--label
zerosize;;goto--jumper-15
#val (used with set to change variable value during runtime.)
setreg1;10x1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>sysbak
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#buffer 2 reset
iowrite1;>buffer.2.reset
#goto 
goto;>main--label
#label
zerosize;;help_ready_splash--label
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#prline
fopwri1;:T
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:?
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:\s
fopwri1;:R
fopwri1;:E
fopwri1;:A
fopwri1;:D
fopwri1;:Y
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;main--label
#Set text colors
dataread1;>*0+0---
iowrite1;>io.textcolor
#Dump (character)
dataread1;>drive
iowrite1;>io.ttywr
#print
fopwri1;::
fopwri1;:\b
fopwri1;:>
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#goto (extra code stores away return address.)
setreg1;>goto--jumper-50
s1push1
goto;>cp.getentry--label
zerosize;;goto--jumper-50
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validflg
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--56
null;;tabstrc--adrbuff--56
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--56
null;;tabstrc--outbuff--56
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--56

datawrite1;>tabstrc--recurs-tabbuff--56_1
dataread1;;tabstrc--recurs-tabbuff--56_1
datawrite1;>tabstrc--recurs-tabbuff_read--56_1
dataread1;;tabstrc--recurs-tabbuff_read--56_1

setreg2;:?


gotoif;>tabstrc--recurs-checkyes--56_1
goto;>tabstrc--recurs-checkno--56_1
zerosize;;tabstrc--recurs-checkyes--56_1
##set flag########
setreg1;>tabstrc--outbuff--56
datawrite1;>tabstrc--recurs-flag--56_1
setreg1;+
datawrite1;;tabstrc--recurs-flag--56_1
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--56_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--56
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-58
goto;>goto--jumper-58
setreg1;>goto--jumper-58;goto--branch-58
s1push1
goto;>help--label
zerosize;;goto--jumper-58
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-59
goto;>goto--jumper-59
dataread1;>@1;goto--branch-59
datawrite1;>validflg
zerosize;;goto--jumper-59
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--60
null;;tabstrc--adrbuff--60
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--60
null;;tabstrc--outbuff--60
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--60

datawrite1;>tabstrc--recurs-tabbuff--60_1
dataread1;;tabstrc--recurs-tabbuff--60_1
datawrite1;>tabstrc--recurs-tabbuff_read--60_1
dataread1;;tabstrc--recurs-tabbuff_read--60_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--60_1
goto;>tabstrc--recurs-checkno--60_1
zerosize;;tabstrc--recurs-checkyes--60_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--60
setreg2;+
add
datawrite1;>tabstrc--adrbuff--60

setreg1;>tabstrc--adrbuff--60

datawrite1;>tabstrc--recurs-tabbuff--60_2
dataread1;;tabstrc--recurs-tabbuff--60_2
datawrite1;>tabstrc--recurs-tabbuff_read--60_2
dataread1;;tabstrc--recurs-tabbuff_read--60_2

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--60_2
goto;>tabstrc--recurs-checkno--60_2
zerosize;;tabstrc--recurs-checkyes--60_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--60
setreg2;+
add
datawrite1;>tabstrc--adrbuff--60

setreg1;>tabstrc--adrbuff--60

datawrite1;>tabstrc--recurs-tabbuff--60_3
dataread1;;tabstrc--recurs-tabbuff--60_3
datawrite1;>tabstrc--recurs-tabbuff_read--60_3
dataread1;;tabstrc--recurs-tabbuff_read--60_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--60_3
goto;>tabstrc--recurs-checkno--60_3
zerosize;;tabstrc--recurs-checkyes--60_3
##set flag########
setreg1;>tabstrc--outbuff--60
datawrite1;>tabstrc--recurs-flag--60_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--60_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--60_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--60_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--60_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--60
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-62
goto;>goto--jumper-62
setreg1;>goto--jumper-62;goto--branch-62
s1push1
goto;>vdi--label
zerosize;;goto--jumper-62
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-63
goto;>goto--jumper-63
dataread1;>@1;goto--branch-63
datawrite1;>validflg
zerosize;;goto--jumper-63
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--64
null;;tabstrc--adrbuff--64
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--64
null;;tabstrc--outbuff--64
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_1
dataread1;;tabstrc--recurs-tabbuff--64_1
datawrite1;>tabstrc--recurs-tabbuff_read--64_1
dataread1;;tabstrc--recurs-tabbuff_read--64_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--64_1
goto;>tabstrc--recurs-checkno--64_1
zerosize;;tabstrc--recurs-checkyes--64_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_2
dataread1;;tabstrc--recurs-tabbuff--64_2
datawrite1;>tabstrc--recurs-tabbuff_read--64_2
dataread1;;tabstrc--recurs-tabbuff_read--64_2

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--64_2
goto;>tabstrc--recurs-checkno--64_2
zerosize;;tabstrc--recurs-checkyes--64_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_3
dataread1;;tabstrc--recurs-tabbuff--64_3
datawrite1;>tabstrc--recurs-tabbuff_read--64_3
dataread1;;tabstrc--recurs-tabbuff_read--64_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--64_3
goto;>tabstrc--recurs-checkno--64_3
zerosize;;tabstrc--recurs-checkyes--64_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_4
dataread1;;tabstrc--recurs-tabbuff--64_4
datawrite1;>tabstrc--recurs-tabbuff_read--64_4
dataread1;;tabstrc--recurs-tabbuff_read--64_4

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--64_4
goto;>tabstrc--recurs-checkno--64_4
zerosize;;tabstrc--recurs-checkyes--64_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_5
dataread1;;tabstrc--recurs-tabbuff--64_5
datawrite1;>tabstrc--recurs-tabbuff_read--64_5
dataread1;;tabstrc--recurs-tabbuff_read--64_5

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--64_5
goto;>tabstrc--recurs-checkno--64_5
zerosize;;tabstrc--recurs-checkyes--64_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64

setreg1;>tabstrc--adrbuff--64

datawrite1;>tabstrc--recurs-tabbuff--64_6
dataread1;;tabstrc--recurs-tabbuff--64_6
datawrite1;>tabstrc--recurs-tabbuff_read--64_6
dataread1;;tabstrc--recurs-tabbuff_read--64_6

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--64_6
goto;>tabstrc--recurs-checkno--64_6
zerosize;;tabstrc--recurs-checkyes--64_6
##set flag########
setreg1;>tabstrc--outbuff--64
datawrite1;>tabstrc--recurs-flag--64_6
setreg1;+
datawrite1;;tabstrc--recurs-flag--64_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64_5
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--64
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-66
goto;>goto--jumper-66
setreg1;>goto--jumper-66;goto--branch-66
s1push1
goto;>drives--label
zerosize;;goto--jumper-66
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-67
goto;>goto--jumper-67
dataread1;>@1;goto--branch-67
datawrite1;>validflg
zerosize;;goto--jumper-67
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--68
null;;tabstrc--adrbuff--68
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--68
null;;tabstrc--outbuff--68
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--68

datawrite1;>tabstrc--recurs-tabbuff--68_1
dataread1;;tabstrc--recurs-tabbuff--68_1
datawrite1;>tabstrc--recurs-tabbuff_read--68_1
dataread1;;tabstrc--recurs-tabbuff_read--68_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--68_1
goto;>tabstrc--recurs-checkno--68_1
zerosize;;tabstrc--recurs-checkyes--68_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--68
setreg2;+
add
datawrite1;>tabstrc--adrbuff--68

setreg1;>tabstrc--adrbuff--68

datawrite1;>tabstrc--recurs-tabbuff--68_2
dataread1;;tabstrc--recurs-tabbuff--68_2
datawrite1;>tabstrc--recurs-tabbuff_read--68_2
dataread1;;tabstrc--recurs-tabbuff_read--68_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--68_2
goto;>tabstrc--recurs-checkno--68_2
zerosize;;tabstrc--recurs-checkyes--68_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--68
setreg2;+
add
datawrite1;>tabstrc--adrbuff--68

setreg1;>tabstrc--adrbuff--68

datawrite1;>tabstrc--recurs-tabbuff--68_3
dataread1;;tabstrc--recurs-tabbuff--68_3
datawrite1;>tabstrc--recurs-tabbuff_read--68_3
dataread1;;tabstrc--recurs-tabbuff_read--68_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--68_3
goto;>tabstrc--recurs-checkno--68_3
zerosize;;tabstrc--recurs-checkyes--68_3
##set flag########
setreg1;>tabstrc--outbuff--68
datawrite1;>tabstrc--recurs-flag--68_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--68_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--68_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--68_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--68_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--68
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-70
goto;>goto--jumper-70
setreg1;>goto--jumper-70;goto--branch-70
s1push1
goto;>version--label
zerosize;;goto--jumper-70
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-71
goto;>goto--jumper-71
dataread1;>@1;goto--branch-71
datawrite1;>validflg
zerosize;;goto--jumper-71
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--72
null;;tabstrc--adrbuff--72
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--72
null;;tabstrc--outbuff--72
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_1
dataread1;;tabstrc--recurs-tabbuff--72_1
datawrite1;>tabstrc--recurs-tabbuff_read--72_1
dataread1;;tabstrc--recurs-tabbuff_read--72_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--72_1
goto;>tabstrc--recurs-checkno--72_1
zerosize;;tabstrc--recurs-checkyes--72_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_2
dataread1;;tabstrc--recurs-tabbuff--72_2
datawrite1;>tabstrc--recurs-tabbuff_read--72_2
dataread1;;tabstrc--recurs-tabbuff_read--72_2

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--72_2
goto;>tabstrc--recurs-checkno--72_2
zerosize;;tabstrc--recurs-checkyes--72_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_3
dataread1;;tabstrc--recurs-tabbuff--72_3
datawrite1;>tabstrc--recurs-tabbuff_read--72_3
dataread1;;tabstrc--recurs-tabbuff_read--72_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--72_3
goto;>tabstrc--recurs-checkno--72_3
zerosize;;tabstrc--recurs-checkyes--72_3
##set flag########
setreg1;>tabstrc--outbuff--72
datawrite1;>tabstrc--recurs-flag--72_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--72_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--72_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--72_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--72_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--72
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-74
goto;>goto--jumper-74
setreg1;>goto--jumper-74;goto--branch-74
s1push1
goto;>directory_list--label
zerosize;;goto--jumper-74
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-75
goto;>goto--jumper-75
dataread1;>@1;goto--branch-75
datawrite1;>validflg
zerosize;;goto--jumper-75
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--76
null;;tabstrc--adrbuff--76
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--76
null;;tabstrc--outbuff--76
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_1
dataread1;;tabstrc--recurs-tabbuff--76_1
datawrite1;>tabstrc--recurs-tabbuff_read--76_1
dataread1;;tabstrc--recurs-tabbuff_read--76_1

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--76_1
goto;>tabstrc--recurs-checkno--76_1
zerosize;;tabstrc--recurs-checkyes--76_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_2
dataread1;;tabstrc--recurs-tabbuff--76_2
datawrite1;>tabstrc--recurs-tabbuff_read--76_2
dataread1;;tabstrc--recurs-tabbuff_read--76_2

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--76_2
goto;>tabstrc--recurs-checkno--76_2
zerosize;;tabstrc--recurs-checkyes--76_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_3
dataread1;;tabstrc--recurs-tabbuff--76_3
datawrite1;>tabstrc--recurs-tabbuff_read--76_3
dataread1;;tabstrc--recurs-tabbuff_read--76_3

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--76_3
goto;>tabstrc--recurs-checkno--76_3
zerosize;;tabstrc--recurs-checkyes--76_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_4
dataread1;;tabstrc--recurs-tabbuff--76_4
datawrite1;>tabstrc--recurs-tabbuff_read--76_4
dataread1;;tabstrc--recurs-tabbuff_read--76_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--76_4
goto;>tabstrc--recurs-checkno--76_4
zerosize;;tabstrc--recurs-checkyes--76_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_5
dataread1;;tabstrc--recurs-tabbuff--76_5
datawrite1;>tabstrc--recurs-tabbuff_read--76_5
dataread1;;tabstrc--recurs-tabbuff_read--76_5

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--76_5
goto;>tabstrc--recurs-checkno--76_5
zerosize;;tabstrc--recurs-checkyes--76_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_6
dataread1;;tabstrc--recurs-tabbuff--76_6
datawrite1;>tabstrc--recurs-tabbuff_read--76_6
dataread1;;tabstrc--recurs-tabbuff_read--76_6

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--76_6
goto;>tabstrc--recurs-checkno--76_6
zerosize;;tabstrc--recurs-checkyes--76_6
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_7
dataread1;;tabstrc--recurs-tabbuff--76_7
datawrite1;>tabstrc--recurs-tabbuff_read--76_7
dataread1;;tabstrc--recurs-tabbuff_read--76_7

setreg2;:w


gotoif;>tabstrc--recurs-checkyes--76_7
goto;>tabstrc--recurs-checkno--76_7
zerosize;;tabstrc--recurs-checkyes--76_7
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_8
dataread1;;tabstrc--recurs-tabbuff--76_8
datawrite1;>tabstrc--recurs-tabbuff_read--76_8
dataread1;;tabstrc--recurs-tabbuff_read--76_8

setreg2;:n


gotoif;>tabstrc--recurs-checkyes--76_8
goto;>tabstrc--recurs-checkno--76_8
zerosize;;tabstrc--recurs-checkyes--76_8
##set flag########
setreg1;>tabstrc--outbuff--76
datawrite1;>tabstrc--recurs-flag--76_8
setreg1;+
datawrite1;;tabstrc--recurs-flag--76_8
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_8
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_7
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_5
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--76
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-78
goto;>goto--jumper-78
setreg1;>goto--jumper-78;goto--branch-78
s1push1
goto;>shutdown--label
zerosize;;goto--jumper-78
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-79
goto;>goto--jumper-79
dataread1;>@1;goto--branch-79
datawrite1;>validflg
zerosize;;goto--jumper-79
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--82
null;;tabstrc--adrbuff--82
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--82
null;;tabstrc--outbuff--82
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--82

datawrite1;>tabstrc--recurs-tabbuff--82_1
dataread1;;tabstrc--recurs-tabbuff--82_1
datawrite1;>tabstrc--recurs-tabbuff_read--82_1
dataread1;;tabstrc--recurs-tabbuff_read--82_1

setreg2;:a


gotoif;>tabstrc--recurs-checkyes--82_1
goto;>tabstrc--recurs-checkno--82_1
zerosize;;tabstrc--recurs-checkyes--82_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--82
setreg2;+
add
datawrite1;>tabstrc--adrbuff--82

setreg1;>tabstrc--adrbuff--82

datawrite1;>tabstrc--recurs-tabbuff--82_2
dataread1;;tabstrc--recurs-tabbuff--82_2
datawrite1;>tabstrc--recurs-tabbuff_read--82_2
dataread1;;tabstrc--recurs-tabbuff_read--82_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--82_2
goto;>tabstrc--recurs-checkno--82_2
zerosize;;tabstrc--recurs-checkyes--82_2
##set flag########
setreg1;>tabstrc--outbuff--82
datawrite1;>tabstrc--recurs-flag--82_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--82_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--82_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--82_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--82
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-84
goto;>goto--jumper-84
setreg1;>goto--jumper-84;goto--branch-84
s1push1
goto;>driveA--label
zerosize;;goto--jumper-84
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-85
goto;>goto--jumper-85
dataread1;>@1;goto--branch-85
datawrite1;>validflg
zerosize;;goto--jumper-85
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--86
null;;tabstrc--adrbuff--86
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--86
null;;tabstrc--outbuff--86
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--86

datawrite1;>tabstrc--recurs-tabbuff--86_1
dataread1;;tabstrc--recurs-tabbuff--86_1
datawrite1;>tabstrc--recurs-tabbuff_read--86_1
dataread1;;tabstrc--recurs-tabbuff_read--86_1

setreg2;:A


gotoif;>tabstrc--recurs-checkyes--86_1
goto;>tabstrc--recurs-checkno--86_1
zerosize;;tabstrc--recurs-checkyes--86_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--86
setreg2;+
add
datawrite1;>tabstrc--adrbuff--86

setreg1;>tabstrc--adrbuff--86

datawrite1;>tabstrc--recurs-tabbuff--86_2
dataread1;;tabstrc--recurs-tabbuff--86_2
datawrite1;>tabstrc--recurs-tabbuff_read--86_2
dataread1;;tabstrc--recurs-tabbuff_read--86_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--86_2
goto;>tabstrc--recurs-checkno--86_2
zerosize;;tabstrc--recurs-checkyes--86_2
##set flag########
setreg1;>tabstrc--outbuff--86
datawrite1;>tabstrc--recurs-flag--86_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--86_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--86_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--86_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--86
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-88
goto;>goto--jumper-88
setreg1;>goto--jumper-88;goto--branch-88
s1push1
goto;>driveA--label
zerosize;;goto--jumper-88
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-89
goto;>goto--jumper-89
dataread1;>@1;goto--branch-89
datawrite1;>validflg
zerosize;;goto--jumper-89
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--91
null;;tabstrc--adrbuff--91
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--91
null;;tabstrc--outbuff--91
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--91

datawrite1;>tabstrc--recurs-tabbuff--91_1
dataread1;;tabstrc--recurs-tabbuff--91_1
datawrite1;>tabstrc--recurs-tabbuff_read--91_1
dataread1;;tabstrc--recurs-tabbuff_read--91_1

setreg2;:b


gotoif;>tabstrc--recurs-checkyes--91_1
goto;>tabstrc--recurs-checkno--91_1
zerosize;;tabstrc--recurs-checkyes--91_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--91
setreg2;+
add
datawrite1;>tabstrc--adrbuff--91

setreg1;>tabstrc--adrbuff--91

datawrite1;>tabstrc--recurs-tabbuff--91_2
dataread1;;tabstrc--recurs-tabbuff--91_2
datawrite1;>tabstrc--recurs-tabbuff_read--91_2
dataread1;;tabstrc--recurs-tabbuff_read--91_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--91_2
goto;>tabstrc--recurs-checkno--91_2
zerosize;;tabstrc--recurs-checkyes--91_2
##set flag########
setreg1;>tabstrc--outbuff--91
datawrite1;>tabstrc--recurs-flag--91_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--91_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--91_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--91_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--91
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-93
goto;>goto--jumper-93
setreg1;>goto--jumper-93;goto--branch-93
s1push1
goto;>driveB--label
zerosize;;goto--jumper-93
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-94
goto;>goto--jumper-94
dataread1;>@1;goto--branch-94
datawrite1;>validflg
zerosize;;goto--jumper-94
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--95
null;;tabstrc--adrbuff--95
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--95
null;;tabstrc--outbuff--95
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--95

datawrite1;>tabstrc--recurs-tabbuff--95_1
dataread1;;tabstrc--recurs-tabbuff--95_1
datawrite1;>tabstrc--recurs-tabbuff_read--95_1
dataread1;;tabstrc--recurs-tabbuff_read--95_1

setreg2;:B


gotoif;>tabstrc--recurs-checkyes--95_1
goto;>tabstrc--recurs-checkno--95_1
zerosize;;tabstrc--recurs-checkyes--95_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--95
setreg2;+
add
datawrite1;>tabstrc--adrbuff--95

setreg1;>tabstrc--adrbuff--95

datawrite1;>tabstrc--recurs-tabbuff--95_2
dataread1;;tabstrc--recurs-tabbuff--95_2
datawrite1;>tabstrc--recurs-tabbuff_read--95_2
dataread1;;tabstrc--recurs-tabbuff_read--95_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--95_2
goto;>tabstrc--recurs-checkno--95_2
zerosize;;tabstrc--recurs-checkyes--95_2
##set flag########
setreg1;>tabstrc--outbuff--95
datawrite1;>tabstrc--recurs-flag--95_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--95_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--95_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--95_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--95
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-97
goto;>goto--jumper-97
setreg1;>goto--jumper-97;goto--branch-97
s1push1
goto;>driveB--label
zerosize;;goto--jumper-97
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-98
goto;>goto--jumper-98
dataread1;>@1;goto--branch-98
datawrite1;>validflg
zerosize;;goto--jumper-98
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--100
null;;tabstrc--adrbuff--100
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--100
null;;tabstrc--outbuff--100
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--100

datawrite1;>tabstrc--recurs-tabbuff--100_1
dataread1;;tabstrc--recurs-tabbuff--100_1
datawrite1;>tabstrc--recurs-tabbuff_read--100_1
dataread1;;tabstrc--recurs-tabbuff_read--100_1

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--100_1
goto;>tabstrc--recurs-checkno--100_1
zerosize;;tabstrc--recurs-checkyes--100_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--100
setreg2;+
add
datawrite1;>tabstrc--adrbuff--100

setreg1;>tabstrc--adrbuff--100

datawrite1;>tabstrc--recurs-tabbuff--100_2
dataread1;;tabstrc--recurs-tabbuff--100_2
datawrite1;>tabstrc--recurs-tabbuff_read--100_2
dataread1;;tabstrc--recurs-tabbuff_read--100_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--100_2
goto;>tabstrc--recurs-checkno--100_2
zerosize;;tabstrc--recurs-checkyes--100_2
##set flag########
setreg1;>tabstrc--outbuff--100
datawrite1;>tabstrc--recurs-flag--100_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--100_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--100_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--100_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--100
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-102
goto;>goto--jumper-102
setreg1;>goto--jumper-102;goto--branch-102
s1push1
goto;>driveR--label
zerosize;;goto--jumper-102
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-103
goto;>goto--jumper-103
dataread1;>@1;goto--branch-103
datawrite1;>validflg
zerosize;;goto--jumper-103
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--104
null;;tabstrc--adrbuff--104
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--104
null;;tabstrc--outbuff--104
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--104

datawrite1;>tabstrc--recurs-tabbuff--104_1
dataread1;;tabstrc--recurs-tabbuff--104_1
datawrite1;>tabstrc--recurs-tabbuff_read--104_1
dataread1;;tabstrc--recurs-tabbuff_read--104_1

setreg2;:R


gotoif;>tabstrc--recurs-checkyes--104_1
goto;>tabstrc--recurs-checkno--104_1
zerosize;;tabstrc--recurs-checkyes--104_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--104
setreg2;+
add
datawrite1;>tabstrc--adrbuff--104

setreg1;>tabstrc--adrbuff--104

datawrite1;>tabstrc--recurs-tabbuff--104_2
dataread1;;tabstrc--recurs-tabbuff--104_2
datawrite1;>tabstrc--recurs-tabbuff_read--104_2
dataread1;;tabstrc--recurs-tabbuff_read--104_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--104_2
goto;>tabstrc--recurs-checkno--104_2
zerosize;;tabstrc--recurs-checkyes--104_2
##set flag########
setreg1;>tabstrc--outbuff--104
datawrite1;>tabstrc--recurs-flag--104_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--104_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--104_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--104_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--104
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-106
goto;>goto--jumper-106
setreg1;>goto--jumper-106;goto--branch-106
s1push1
goto;>driveR--label
zerosize;;goto--jumper-106
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-107
goto;>goto--jumper-107
dataread1;>@1;goto--branch-107
datawrite1;>validflg
zerosize;;goto--jumper-107
#conditional subroutine goto
dataread1;>validflg
dataread2;>@0
gotoif;>goto--branch-109
goto;>goto--jumper-109
setreg1;>goto--jumper-109;goto--branch-109
s1push1
goto;>invalid--label
zerosize;;goto--jumper-109
#goto 
goto;>main--label
#label
zerosize;;driveA--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-117
goto;>goto--jumper-117
setreg1;>goto--jumper-117;goto--branch-117
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-117
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-119
goto;>goto--branch-119
goto;>flow--con-x-1;goto--branch-119

zerosize;;goto--jumper-119
#val (used with set to change variable value during runtime.)
setreg1;:A
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-1
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-127
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-127
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-128;uiter-loopback-128
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-128
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-128
gotoif;>uiter-loopback-128

#goto (extra code stores away return address.)
setreg1;>goto--jumper-129
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-129
#goto (extra code stores away return address.)
setreg1;>goto--jumper-132
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-132
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;driveB--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-141
goto;>goto--branch-141
goto;>flow--con-x-2;goto--branch-141

zerosize;;goto--jumper-141
#val (used with set to change variable value during runtime.)
setreg1;:B
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-2
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-149
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-149
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-150;uiter-loopback-150
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-150
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-150
gotoif;>uiter-loopback-150

#goto (extra code stores away return address.)
setreg1;>goto--jumper-151
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-151
#goto (extra code stores away return address.)
setreg1;>goto--jumper-154
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-154
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;driveR--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-163
goto;>goto--jumper-163
setreg1;>goto--jumper-163;goto--branch-163
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-163
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-165
goto;>goto--branch-165
goto;>flow--con-x-3;goto--branch-165

zerosize;;goto--jumper-165
#val (used with set to change variable value during runtime.)
setreg1;:R
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-3
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-174
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-174
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-175;uiter-loopback-175
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-175
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-175
gotoif;>uiter-loopback-175

#goto (extra code stores away return address.)
setreg1;>goto--jumper-176
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-176
#goto (extra code stores away return address.)
setreg1;>goto--jumper-179
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-179
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list--label
#conditional subroutine goto
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-186
goto;>goto--jumper-186
setreg1;>goto--jumper-186;goto--branch-186
s1push1
goto;>directory_list_R--label
zerosize;;goto--jumper-186
#conditional subroutine goto
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-187
goto;>goto--jumper-187
setreg1;>goto--jumper-187;goto--branch-187
s1push1
goto;>directory_list_B--label
zerosize;;goto--jumper-187
#conditional subroutine goto
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-188
goto;>goto--jumper-188
setreg1;>goto--jumper-188;goto--branch-188
s1push1
goto;>directory_list_A--label
zerosize;;goto--jumper-188
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_A--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:A
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-193;uiter-loopback-193
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-193
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-193
gotoif;>uiter-loopback-193

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-196;uiter-loopback-196
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-196
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-196
gotoif;>uiter-loopback-196

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-198
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-198
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_B--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:B
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-203;uiter-loopback-203
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-203
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-203
gotoif;>uiter-loopback-203

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-206;uiter-loopback-206
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-206
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-206
gotoif;>uiter-loopback-206

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-208
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-208
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_R--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-213;uiter-loopback-213
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-213
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-213
gotoif;>uiter-loopback-213

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-216;uiter-loopback-216
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-216
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-216
gotoif;>uiter-loopback-216

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-218
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-218
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;invalid--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-229
goto;>goto--jumper-229
setreg1;>goto--jumper-229;goto--branch-229
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-229
#Set text colors
dataread1;>*++0---
iowrite1;>io.textcolor
#conditional flow control begin
dataread1;>cp.size
dataread2;>@2
gotoifless;>goto--branch-232
goto;>goto--jumper-232
goto;>flow--con-x-4;goto--branch-232

zerosize;;goto--jumper-232
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>@1
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--235
dataread1;;tabr--adrbuff--235
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>invalid_charcheck
#conditional flow control begin
dataread1;>invalid_charcheck
dataread2;>::
gotoif;>goto--jumper-237
goto;>goto--branch-237
goto;>flow--con-x-5;goto--branch-237

zerosize;;goto--jumper-237
#prline
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:N
fopwri1;:o
fopwri1;:t
fopwri1;:\s
fopwri1;:V
fopwri1;:a
fopwri1;:l
fopwri1;:i
fopwri1;:d
fopwri1;:.
fopwri1;:\s
fopwri1;:s
fopwri1;:e
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:d
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:s
fopwri1;:'
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-5
zerosize;;flow--con-x-4
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopset1;>io.ttywr
#conditional set
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-245
goto;>goto--jumper-245
dataread1;>:0;goto--branch-245
datawrite1;>driveref
zerosize;;goto--jumper-245
#conditional set
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-246
goto;>goto--jumper-246
dataread1;>:1;goto--branch-246
datawrite1;>driveref
zerosize;;goto--jumper-246
#conditional set
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-247
goto;>goto--jumper-247
dataread1;>:2;goto--branch-247
datawrite1;>driveref
zerosize;;goto--jumper-247
#get(1) (may be used with set, or asm code)
dataread1;>driveref
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #249
iowrite1;>vdi.cli.in#SSTNPL Source Line: '249' 
#vdin
fopset1;>vdi.cli.in
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-251
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-251
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-252;uiter-loopback-252
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-252
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-252
gotoif;>uiter-loopback-252

#goto (extra code stores away return address.)
setreg1;>goto--jumper-253
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-253
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-257
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-257
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-258;uiter-loopback-258
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-258
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-258
gotoif;>uiter-loopback-258

#goto (extra code stores away return address.)
setreg1;>goto--jumper-259
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-259
#goto (extra code stores away return address.)
setreg1;>goto--jumper-261
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-261
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;extcheck--label
#return from subroutine.
s1pop1
gotoreg1
#subtract (2op math)
dataread1;>cp.size
dataread2;>@4
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extoffset
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>extoffset
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--274
null;;tabstrc--adrbuff--274
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--274
null;;tabstrc--outbuff--274
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--274

datawrite1;>tabstrc--recurs-tabbuff--274_1
dataread1;;tabstrc--recurs-tabbuff--274_1
datawrite1;>tabstrc--recurs-tabbuff_read--274_1
dataread1;;tabstrc--recurs-tabbuff_read--274_1

setreg2;:.


gotoif;>tabstrc--recurs-checkyes--274_1
goto;>tabstrc--recurs-checkno--274_1
zerosize;;tabstrc--recurs-checkyes--274_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--274
setreg2;+
add
datawrite1;>tabstrc--adrbuff--274

setreg1;>tabstrc--adrbuff--274

datawrite1;>tabstrc--recurs-tabbuff--274_2
dataread1;;tabstrc--recurs-tabbuff--274_2
datawrite1;>tabstrc--recurs-tabbuff_read--274_2
dataread1;;tabstrc--recurs-tabbuff_read--274_2

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--274_2
goto;>tabstrc--recurs-checkno--274_2
zerosize;;tabstrc--recurs-checkyes--274_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--274
setreg2;+
add
datawrite1;>tabstrc--adrbuff--274

setreg1;>tabstrc--adrbuff--274

datawrite1;>tabstrc--recurs-tabbuff--274_3
dataread1;;tabstrc--recurs-tabbuff--274_3
datawrite1;>tabstrc--recurs-tabbuff_read--274_3
dataread1;;tabstrc--recurs-tabbuff_read--274_3

setreg2;:x


gotoif;>tabstrc--recurs-checkyes--274_3
goto;>tabstrc--recurs-checkno--274_3
zerosize;;tabstrc--recurs-checkyes--274_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--274
setreg2;+
add
datawrite1;>tabstrc--adrbuff--274

setreg1;>tabstrc--adrbuff--274

datawrite1;>tabstrc--recurs-tabbuff--274_4
dataread1;;tabstrc--recurs-tabbuff--274_4
datawrite1;>tabstrc--recurs-tabbuff_read--274_4
dataread1;;tabstrc--recurs-tabbuff_read--274_4

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--274_4
goto;>tabstrc--recurs-checkno--274_4
zerosize;;tabstrc--recurs-checkyes--274_4
##set flag########
setreg1;>tabstrc--outbuff--274
datawrite1;>tabstrc--recurs-flag--274_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--274_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--274
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;cmd_run_send_newline--label
#conditional flow control begin
dataread1;>extflg
dataread2;>$false
gotoif;>goto--jumper-281
goto;>goto--branch-281
goto;>flow--con-x-6;goto--branch-281

zerosize;;goto--jumper-281
#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-6
#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_setup--label
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_char_exec--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--300
dataread1;;tabr--adrbuff--300
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_s_tmp
#conditional flow control begin
dataread1;>run_tobuffer_flg
dataread2;>@0
gotoif;>goto--jumper-302
goto;>goto--branch-302
goto;>flow--con-x-7;goto--branch-302

zerosize;;goto--jumper-302
#conditional set
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-303
goto;>goto--jumper-303
dataread1;>@1;goto--branch-303
datawrite1;>run_tobuffer_flg
zerosize;;goto--jumper-303
#conditional return
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-304
goto;>goto--jumper-304
s1pop1;;goto--branch-304
gotoreg1
zerosize;;goto--jumper-304
#get(1) (may be used with set, or asm code)
dataread1;>run_s_tmp
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #307
iowrite1;>vdi.cli.in#SSTNPL Source Line: '307' 
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-7
#buffer 2 head write
dataread1;>run_s_tmp
iowrite1;>buffer.2.write.head
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--315
dataread1;;tabr--adrbuff--315
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #316
iowrite1;>vdi.cli.in#SSTNPL Source Line: '316' 
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;pattern_print_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--320
dataread1;;tabr--adrbuff--320
iowrite1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;version--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-324
s1push1
goto;>splash--label
zerosize;;goto--jumper-324
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#prline
fopwri1;:\s
fopwri1;:C
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:I
fopwri1;:n
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:p
fopwri1;:r
fopwri1;:e
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:\s
fopwri1;:v
fopwri1;:2
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;vdi--label
#val (used with set to change variable value during runtime.)
setreg1;10x1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #334
iowrite1;>vdi.cli.status#SSTNPL Source Line: '334' 
#Upward range iterator
dataread1;>@4
datawrite1;>vdi_iter
setreg1;>uiter-retpos-336;uiter-loopback-336
s1push1
goto;>vdi_buffiter--label
dataread1;>vdi_iter;uiter-retpos-336
setreg2;10x1
add
datawrite1;>vdi_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-336
gotoif;>uiter-loopback-336

#val (used with set to change variable value during runtime.)
setreg1;:\n
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #338
iowrite1;>vdi.cli.in#SSTNPL Source Line: '338' 
#goto 
goto;>vdi_outloop--label
#label
zerosize;;vdi_outloop--label
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #345
ioread1;>vdi.cli.out#SSTNPL Source Line: '345' 
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>vdi_vdioutput_buffer
#conditional return
dataread1;>vdi_vdioutput_buffer
dataread2;>@0
gotoif;>goto--branch-348
goto;>goto--jumper-348
s1pop1;;goto--branch-348
gotoreg1
zerosize;;goto--jumper-348
#Dump (character)
dataread1;>vdi_vdioutput_buffer
iowrite1;>io.ttywr
#goto 
goto;>vdi_outloop--label
#label
zerosize;;drives--label
#prline
fopwri1;:A
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:B
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:R
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:H
fopwri1;:a
fopwri1;:r
fopwri1;:d
fopwri1;:w
fopwri1;:a
fopwri1;:r
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:a
fopwri1;:m
fopwri1;:d
fopwri1;:i
fopwri1;:s
fopwri1;:k
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;vdi_buffiter--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>vdi_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--361
dataread1;;tabr--adrbuff--361
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #362
iowrite1;>vdi.cli.in#SSTNPL Source Line: '362' 
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;help--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#bprinthead2n
fopset1;>buffer.2.write.head
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopset1;>io.ttywr
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;splash--label
#Set text colors
dataread1;>*+++0--
iowrite1;>io.textcolor
#print
fopwri1;:S
#Set text colors
dataread1;>*+++00-
iowrite1;>io.textcolor
#print
fopwri1;:B
#Set text colors
dataread1;>*+++-0-
iowrite1;>io.textcolor
#print
fopwri1;:T
#Set text colors
dataread1;>*+++-00
iowrite1;>io.textcolor
#print
fopwri1;:C
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#print
fopwri1;:V
#Set text colors
dataread1;>*+++0-0
iowrite1;>io.textcolor
#print
fopwri1;:M
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print
fopwri1;:-
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:D
fopwri1;:O
fopwri1;:S
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;shutdown--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-397
s1push1
goto;>splash--label
zerosize;;goto--jumper-397
#prline
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:u
fopwri1;:t
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:d
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:.
fopwri1;:.
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:d
fopwri1;:o
fopwri1;:n
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#stop (shutdown vm)
stop
#module include: line 405: comprompt as cp
includeas;comprompt,cp
#END OF FILE
