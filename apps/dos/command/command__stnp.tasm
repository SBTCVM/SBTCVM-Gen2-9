#SSTNPL COMPILER v0.4.0
#header
head-rname=command
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "apps/dos/command/command.stnp
null;0;sysbak
null;10x1;$true
null;10x1;@1
null;10x0;$false
null;+++---;*+++---
null;0;cmdflg
null;0;validflg
null;:A;drive
null;0+0---;*0+0---
null;10x0;@0
null;10x4;@4
null;10x3;@3
null;10x0;run_iter
null;:R;:R
null;:B;:B
null;:A;:A
null;:0;driveref
null;0;invalid_charcheck
null;0;extflg
null;0;extoffset
null;++0---;*++0---
null;10x2;@2
null;::;::
null;:0;:0
null;:1;:1
null;:2;:2
null;0;run_s_tmp
null;0;run_tobuffer_flg
null;:\s;:\s
null;0++---;*0++---
null;0;vdi_vdioutput_buffer
null;10x0;vdi_iter
null;+++0--;*+++0--
null;+++00-;*+++00-
null;+++-0-;*+++-0-
null;+++-00;*+++-00
null;+++--0;*+++--0
null;+++0-0;*+++0-0
#conditional goto
dataread1;>sysbak
dataread2;>$true
gotoif;>goto--branch-4-0
goto;>goto--jumper-4-0
setreg1;>goto--jumper-4-0;goto--branch-4-0
goto;>startup--label
zerosize;;goto--jumper-4-0
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#label
zerosize;;startup--label
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-14-0
goto;>goto--jumper-14-0
setreg1;>goto--jumper-14-0;goto--branch-14-0
s1push1
goto;>version--label
zerosize;;goto--jumper-14-0
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-15-0
goto;>goto--jumper-15-0
setreg1;>goto--jumper-15-0;goto--branch-15-0
s1push1
goto;>help_ready_splash--label
zerosize;;goto--jumper-15-0
#val (used with set to change variable value during runtime.)
setreg1;10x1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>sysbak
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#buffer 2 reset
iowrite1;>buffer.2.reset
#goto 
goto;>main--label
#label
zerosize;;help_ready_splash--label
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#prline
fopwri1;:T
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:?
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:\s
fopwri1;:R
fopwri1;:E
fopwri1;:A
fopwri1;:D
fopwri1;:Y
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;main--label
#Set text colors
dataread1;>*0+0---
iowrite1;>io.textcolor
#Dump (character)
dataread1;>drive
iowrite1;>io.ttywr
#print
fopwri1;::
fopwri1;:\b
fopwri1;:>
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#goto (extra code stores away return address.)
setreg1;>goto--jumper-50-0
s1push1
goto;>cp.getentry--label
zerosize;;goto--jumper-50-0
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validflg
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--56-0
null;;tabstrc--adrbuff--56-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--56-0
null;;tabstrc--outbuff--56-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--56-0

datawrite1;>tabstrc--recurs-tabbuff--56-0_1
dataread1;;tabstrc--recurs-tabbuff--56-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--56-0_1
dataread1;;tabstrc--recurs-tabbuff_read--56-0_1

setreg2;:?


gotoif;>tabstrc--recurs-checkyes--56-0_1
goto;>tabstrc--recurs-checkno--56-0_1
zerosize;;tabstrc--recurs-checkyes--56-0_1
##set flag########
setreg1;>tabstrc--outbuff--56-0
datawrite1;>tabstrc--recurs-flag--56-0_1
setreg1;+
datawrite1;;tabstrc--recurs-flag--56-0_1
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--56-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--56-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-58-0
goto;>goto--jumper-58-0
setreg1;>goto--jumper-58-0;goto--branch-58-0
s1push1
goto;>help--label
zerosize;;goto--jumper-58-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-59-0
goto;>goto--jumper-59-0
dataread1;>@1;goto--branch-59-0
datawrite1;>validflg
zerosize;;goto--jumper-59-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--60-0
null;;tabstrc--adrbuff--60-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--60-0
null;;tabstrc--outbuff--60-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--60-0

datawrite1;>tabstrc--recurs-tabbuff--60-0_1
dataread1;;tabstrc--recurs-tabbuff--60-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--60-0_1
dataread1;;tabstrc--recurs-tabbuff_read--60-0_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--60-0_1
goto;>tabstrc--recurs-checkno--60-0_1
zerosize;;tabstrc--recurs-checkyes--60-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--60-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--60-0

setreg1;>tabstrc--adrbuff--60-0

datawrite1;>tabstrc--recurs-tabbuff--60-0_2
dataread1;;tabstrc--recurs-tabbuff--60-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--60-0_2
dataread1;;tabstrc--recurs-tabbuff_read--60-0_2

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--60-0_2
goto;>tabstrc--recurs-checkno--60-0_2
zerosize;;tabstrc--recurs-checkyes--60-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--60-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--60-0

setreg1;>tabstrc--adrbuff--60-0

datawrite1;>tabstrc--recurs-tabbuff--60-0_3
dataread1;;tabstrc--recurs-tabbuff--60-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--60-0_3
dataread1;;tabstrc--recurs-tabbuff_read--60-0_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--60-0_3
goto;>tabstrc--recurs-checkno--60-0_3
zerosize;;tabstrc--recurs-checkyes--60-0_3
##set flag########
setreg1;>tabstrc--outbuff--60-0
datawrite1;>tabstrc--recurs-flag--60-0_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--60-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--60-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--60-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--60-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--60-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-62-0
goto;>goto--jumper-62-0
setreg1;>goto--jumper-62-0;goto--branch-62-0
s1push1
goto;>vdi--label
zerosize;;goto--jumper-62-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-63-0
goto;>goto--jumper-63-0
dataread1;>@1;goto--branch-63-0
datawrite1;>validflg
zerosize;;goto--jumper-63-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--64-0
null;;tabstrc--adrbuff--64-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--64-0
null;;tabstrc--outbuff--64-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--64-0

datawrite1;>tabstrc--recurs-tabbuff--64-0_1
dataread1;;tabstrc--recurs-tabbuff--64-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--64-0_1
dataread1;;tabstrc--recurs-tabbuff_read--64-0_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--64-0_1
goto;>tabstrc--recurs-checkno--64-0_1
zerosize;;tabstrc--recurs-checkyes--64-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64-0

setreg1;>tabstrc--adrbuff--64-0

datawrite1;>tabstrc--recurs-tabbuff--64-0_2
dataread1;;tabstrc--recurs-tabbuff--64-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--64-0_2
dataread1;;tabstrc--recurs-tabbuff_read--64-0_2

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--64-0_2
goto;>tabstrc--recurs-checkno--64-0_2
zerosize;;tabstrc--recurs-checkyes--64-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64-0

setreg1;>tabstrc--adrbuff--64-0

datawrite1;>tabstrc--recurs-tabbuff--64-0_3
dataread1;;tabstrc--recurs-tabbuff--64-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--64-0_3
dataread1;;tabstrc--recurs-tabbuff_read--64-0_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--64-0_3
goto;>tabstrc--recurs-checkno--64-0_3
zerosize;;tabstrc--recurs-checkyes--64-0_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64-0

setreg1;>tabstrc--adrbuff--64-0

datawrite1;>tabstrc--recurs-tabbuff--64-0_4
dataread1;;tabstrc--recurs-tabbuff--64-0_4
datawrite1;>tabstrc--recurs-tabbuff_read--64-0_4
dataread1;;tabstrc--recurs-tabbuff_read--64-0_4

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--64-0_4
goto;>tabstrc--recurs-checkno--64-0_4
zerosize;;tabstrc--recurs-checkyes--64-0_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64-0

setreg1;>tabstrc--adrbuff--64-0

datawrite1;>tabstrc--recurs-tabbuff--64-0_5
dataread1;;tabstrc--recurs-tabbuff--64-0_5
datawrite1;>tabstrc--recurs-tabbuff_read--64-0_5
dataread1;;tabstrc--recurs-tabbuff_read--64-0_5

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--64-0_5
goto;>tabstrc--recurs-checkno--64-0_5
zerosize;;tabstrc--recurs-checkyes--64-0_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--64-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--64-0

setreg1;>tabstrc--adrbuff--64-0

datawrite1;>tabstrc--recurs-tabbuff--64-0_6
dataread1;;tabstrc--recurs-tabbuff--64-0_6
datawrite1;>tabstrc--recurs-tabbuff_read--64-0_6
dataread1;;tabstrc--recurs-tabbuff_read--64-0_6

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--64-0_6
goto;>tabstrc--recurs-checkno--64-0_6
zerosize;;tabstrc--recurs-checkyes--64-0_6
##set flag########
setreg1;>tabstrc--outbuff--64-0
datawrite1;>tabstrc--recurs-flag--64-0_6
setreg1;+
datawrite1;;tabstrc--recurs-flag--64-0_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64-0_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64-0_5
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64-0_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--64-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--64-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-66-0
goto;>goto--jumper-66-0
setreg1;>goto--jumper-66-0;goto--branch-66-0
s1push1
goto;>drives--label
zerosize;;goto--jumper-66-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-67-0
goto;>goto--jumper-67-0
dataread1;>@1;goto--branch-67-0
datawrite1;>validflg
zerosize;;goto--jumper-67-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--68-0
null;;tabstrc--adrbuff--68-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--68-0
null;;tabstrc--outbuff--68-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--68-0

datawrite1;>tabstrc--recurs-tabbuff--68-0_1
dataread1;;tabstrc--recurs-tabbuff--68-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--68-0_1
dataread1;;tabstrc--recurs-tabbuff_read--68-0_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--68-0_1
goto;>tabstrc--recurs-checkno--68-0_1
zerosize;;tabstrc--recurs-checkyes--68-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--68-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--68-0

setreg1;>tabstrc--adrbuff--68-0

datawrite1;>tabstrc--recurs-tabbuff--68-0_2
dataread1;;tabstrc--recurs-tabbuff--68-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--68-0_2
dataread1;;tabstrc--recurs-tabbuff_read--68-0_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--68-0_2
goto;>tabstrc--recurs-checkno--68-0_2
zerosize;;tabstrc--recurs-checkyes--68-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--68-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--68-0

setreg1;>tabstrc--adrbuff--68-0

datawrite1;>tabstrc--recurs-tabbuff--68-0_3
dataread1;;tabstrc--recurs-tabbuff--68-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--68-0_3
dataread1;;tabstrc--recurs-tabbuff_read--68-0_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--68-0_3
goto;>tabstrc--recurs-checkno--68-0_3
zerosize;;tabstrc--recurs-checkyes--68-0_3
##set flag########
setreg1;>tabstrc--outbuff--68-0
datawrite1;>tabstrc--recurs-flag--68-0_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--68-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--68-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--68-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--68-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--68-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-70-0
goto;>goto--jumper-70-0
setreg1;>goto--jumper-70-0;goto--branch-70-0
s1push1
goto;>version--label
zerosize;;goto--jumper-70-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-71-0
goto;>goto--jumper-71-0
dataread1;>@1;goto--branch-71-0
datawrite1;>validflg
zerosize;;goto--jumper-71-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--72-0
null;;tabstrc--adrbuff--72-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--72-0
null;;tabstrc--outbuff--72-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--72-0

datawrite1;>tabstrc--recurs-tabbuff--72-0_1
dataread1;;tabstrc--recurs-tabbuff--72-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--72-0_1
dataread1;;tabstrc--recurs-tabbuff_read--72-0_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--72-0_1
goto;>tabstrc--recurs-checkno--72-0_1
zerosize;;tabstrc--recurs-checkyes--72-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72-0

setreg1;>tabstrc--adrbuff--72-0

datawrite1;>tabstrc--recurs-tabbuff--72-0_2
dataread1;;tabstrc--recurs-tabbuff--72-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--72-0_2
dataread1;;tabstrc--recurs-tabbuff_read--72-0_2

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--72-0_2
goto;>tabstrc--recurs-checkno--72-0_2
zerosize;;tabstrc--recurs-checkyes--72-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72-0

setreg1;>tabstrc--adrbuff--72-0

datawrite1;>tabstrc--recurs-tabbuff--72-0_3
dataread1;;tabstrc--recurs-tabbuff--72-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--72-0_3
dataread1;;tabstrc--recurs-tabbuff_read--72-0_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--72-0_3
goto;>tabstrc--recurs-checkno--72-0_3
zerosize;;tabstrc--recurs-checkyes--72-0_3
##set flag########
setreg1;>tabstrc--outbuff--72-0
datawrite1;>tabstrc--recurs-flag--72-0_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--72-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--72-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--72-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--72-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--72-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-74-0
goto;>goto--jumper-74-0
setreg1;>goto--jumper-74-0;goto--branch-74-0
s1push1
goto;>directory_list--label
zerosize;;goto--jumper-74-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-75-0
goto;>goto--jumper-75-0
dataread1;>@1;goto--branch-75-0
datawrite1;>validflg
zerosize;;goto--jumper-75-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--76-0
null;;tabstrc--adrbuff--76-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--76-0
null;;tabstrc--outbuff--76-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_1
dataread1;;tabstrc--recurs-tabbuff--76-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_1
dataread1;;tabstrc--recurs-tabbuff_read--76-0_1

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--76-0_1
goto;>tabstrc--recurs-checkno--76-0_1
zerosize;;tabstrc--recurs-checkyes--76-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_2
dataread1;;tabstrc--recurs-tabbuff--76-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_2
dataread1;;tabstrc--recurs-tabbuff_read--76-0_2

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--76-0_2
goto;>tabstrc--recurs-checkno--76-0_2
zerosize;;tabstrc--recurs-checkyes--76-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_3
dataread1;;tabstrc--recurs-tabbuff--76-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_3
dataread1;;tabstrc--recurs-tabbuff_read--76-0_3

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--76-0_3
goto;>tabstrc--recurs-checkno--76-0_3
zerosize;;tabstrc--recurs-checkyes--76-0_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_4
dataread1;;tabstrc--recurs-tabbuff--76-0_4
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_4
dataread1;;tabstrc--recurs-tabbuff_read--76-0_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--76-0_4
goto;>tabstrc--recurs-checkno--76-0_4
zerosize;;tabstrc--recurs-checkyes--76-0_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_5
dataread1;;tabstrc--recurs-tabbuff--76-0_5
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_5
dataread1;;tabstrc--recurs-tabbuff_read--76-0_5

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--76-0_5
goto;>tabstrc--recurs-checkno--76-0_5
zerosize;;tabstrc--recurs-checkyes--76-0_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_6
dataread1;;tabstrc--recurs-tabbuff--76-0_6
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_6
dataread1;;tabstrc--recurs-tabbuff_read--76-0_6

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--76-0_6
goto;>tabstrc--recurs-checkno--76-0_6
zerosize;;tabstrc--recurs-checkyes--76-0_6
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_7
dataread1;;tabstrc--recurs-tabbuff--76-0_7
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_7
dataread1;;tabstrc--recurs-tabbuff_read--76-0_7

setreg2;:w


gotoif;>tabstrc--recurs-checkyes--76-0_7
goto;>tabstrc--recurs-checkno--76-0_7
zerosize;;tabstrc--recurs-checkyes--76-0_7
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76-0

setreg1;>tabstrc--adrbuff--76-0

datawrite1;>tabstrc--recurs-tabbuff--76-0_8
dataread1;;tabstrc--recurs-tabbuff--76-0_8
datawrite1;>tabstrc--recurs-tabbuff_read--76-0_8
dataread1;;tabstrc--recurs-tabbuff_read--76-0_8

setreg2;:n


gotoif;>tabstrc--recurs-checkyes--76-0_8
goto;>tabstrc--recurs-checkno--76-0_8
zerosize;;tabstrc--recurs-checkyes--76-0_8
##set flag########
setreg1;>tabstrc--outbuff--76-0
datawrite1;>tabstrc--recurs-flag--76-0_8
setreg1;+
datawrite1;;tabstrc--recurs-flag--76-0_8
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_8
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_7
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_5
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--76-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--76-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-78-0
goto;>goto--jumper-78-0
setreg1;>goto--jumper-78-0;goto--branch-78-0
s1push1
goto;>shutdown--label
zerosize;;goto--jumper-78-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-79-0
goto;>goto--jumper-79-0
dataread1;>@1;goto--branch-79-0
datawrite1;>validflg
zerosize;;goto--jumper-79-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--82-0
null;;tabstrc--adrbuff--82-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--82-0
null;;tabstrc--outbuff--82-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--82-0

datawrite1;>tabstrc--recurs-tabbuff--82-0_1
dataread1;;tabstrc--recurs-tabbuff--82-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--82-0_1
dataread1;;tabstrc--recurs-tabbuff_read--82-0_1

setreg2;:a


gotoif;>tabstrc--recurs-checkyes--82-0_1
goto;>tabstrc--recurs-checkno--82-0_1
zerosize;;tabstrc--recurs-checkyes--82-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--82-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--82-0

setreg1;>tabstrc--adrbuff--82-0

datawrite1;>tabstrc--recurs-tabbuff--82-0_2
dataread1;;tabstrc--recurs-tabbuff--82-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--82-0_2
dataread1;;tabstrc--recurs-tabbuff_read--82-0_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--82-0_2
goto;>tabstrc--recurs-checkno--82-0_2
zerosize;;tabstrc--recurs-checkyes--82-0_2
##set flag########
setreg1;>tabstrc--outbuff--82-0
datawrite1;>tabstrc--recurs-flag--82-0_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--82-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--82-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--82-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--82-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-84-0
goto;>goto--jumper-84-0
setreg1;>goto--jumper-84-0;goto--branch-84-0
s1push1
goto;>driveA--label
zerosize;;goto--jumper-84-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-85-0
goto;>goto--jumper-85-0
dataread1;>@1;goto--branch-85-0
datawrite1;>validflg
zerosize;;goto--jumper-85-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--86-0
null;;tabstrc--adrbuff--86-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--86-0
null;;tabstrc--outbuff--86-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--86-0

datawrite1;>tabstrc--recurs-tabbuff--86-0_1
dataread1;;tabstrc--recurs-tabbuff--86-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--86-0_1
dataread1;;tabstrc--recurs-tabbuff_read--86-0_1

setreg2;:A


gotoif;>tabstrc--recurs-checkyes--86-0_1
goto;>tabstrc--recurs-checkno--86-0_1
zerosize;;tabstrc--recurs-checkyes--86-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--86-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--86-0

setreg1;>tabstrc--adrbuff--86-0

datawrite1;>tabstrc--recurs-tabbuff--86-0_2
dataread1;;tabstrc--recurs-tabbuff--86-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--86-0_2
dataread1;;tabstrc--recurs-tabbuff_read--86-0_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--86-0_2
goto;>tabstrc--recurs-checkno--86-0_2
zerosize;;tabstrc--recurs-checkyes--86-0_2
##set flag########
setreg1;>tabstrc--outbuff--86-0
datawrite1;>tabstrc--recurs-flag--86-0_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--86-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--86-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--86-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--86-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-88-0
goto;>goto--jumper-88-0
setreg1;>goto--jumper-88-0;goto--branch-88-0
s1push1
goto;>driveA--label
zerosize;;goto--jumper-88-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-89-0
goto;>goto--jumper-89-0
dataread1;>@1;goto--branch-89-0
datawrite1;>validflg
zerosize;;goto--jumper-89-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--91-0
null;;tabstrc--adrbuff--91-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--91-0
null;;tabstrc--outbuff--91-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--91-0

datawrite1;>tabstrc--recurs-tabbuff--91-0_1
dataread1;;tabstrc--recurs-tabbuff--91-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--91-0_1
dataread1;;tabstrc--recurs-tabbuff_read--91-0_1

setreg2;:b


gotoif;>tabstrc--recurs-checkyes--91-0_1
goto;>tabstrc--recurs-checkno--91-0_1
zerosize;;tabstrc--recurs-checkyes--91-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--91-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--91-0

setreg1;>tabstrc--adrbuff--91-0

datawrite1;>tabstrc--recurs-tabbuff--91-0_2
dataread1;;tabstrc--recurs-tabbuff--91-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--91-0_2
dataread1;;tabstrc--recurs-tabbuff_read--91-0_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--91-0_2
goto;>tabstrc--recurs-checkno--91-0_2
zerosize;;tabstrc--recurs-checkyes--91-0_2
##set flag########
setreg1;>tabstrc--outbuff--91-0
datawrite1;>tabstrc--recurs-flag--91-0_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--91-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--91-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--91-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--91-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-93-0
goto;>goto--jumper-93-0
setreg1;>goto--jumper-93-0;goto--branch-93-0
s1push1
goto;>driveB--label
zerosize;;goto--jumper-93-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-94-0
goto;>goto--jumper-94-0
dataread1;>@1;goto--branch-94-0
datawrite1;>validflg
zerosize;;goto--jumper-94-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--95-0
null;;tabstrc--adrbuff--95-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--95-0
null;;tabstrc--outbuff--95-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--95-0

datawrite1;>tabstrc--recurs-tabbuff--95-0_1
dataread1;;tabstrc--recurs-tabbuff--95-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--95-0_1
dataread1;;tabstrc--recurs-tabbuff_read--95-0_1

setreg2;:B


gotoif;>tabstrc--recurs-checkyes--95-0_1
goto;>tabstrc--recurs-checkno--95-0_1
zerosize;;tabstrc--recurs-checkyes--95-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--95-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--95-0

setreg1;>tabstrc--adrbuff--95-0

datawrite1;>tabstrc--recurs-tabbuff--95-0_2
dataread1;;tabstrc--recurs-tabbuff--95-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--95-0_2
dataread1;;tabstrc--recurs-tabbuff_read--95-0_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--95-0_2
goto;>tabstrc--recurs-checkno--95-0_2
zerosize;;tabstrc--recurs-checkyes--95-0_2
##set flag########
setreg1;>tabstrc--outbuff--95-0
datawrite1;>tabstrc--recurs-flag--95-0_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--95-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--95-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--95-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--95-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-97-0
goto;>goto--jumper-97-0
setreg1;>goto--jumper-97-0;goto--branch-97-0
s1push1
goto;>driveB--label
zerosize;;goto--jumper-97-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-98-0
goto;>goto--jumper-98-0
dataread1;>@1;goto--branch-98-0
datawrite1;>validflg
zerosize;;goto--jumper-98-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--100-0
null;;tabstrc--adrbuff--100-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--100-0
null;;tabstrc--outbuff--100-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--100-0

datawrite1;>tabstrc--recurs-tabbuff--100-0_1
dataread1;;tabstrc--recurs-tabbuff--100-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--100-0_1
dataread1;;tabstrc--recurs-tabbuff_read--100-0_1

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--100-0_1
goto;>tabstrc--recurs-checkno--100-0_1
zerosize;;tabstrc--recurs-checkyes--100-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--100-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--100-0

setreg1;>tabstrc--adrbuff--100-0

datawrite1;>tabstrc--recurs-tabbuff--100-0_2
dataread1;;tabstrc--recurs-tabbuff--100-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--100-0_2
dataread1;;tabstrc--recurs-tabbuff_read--100-0_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--100-0_2
goto;>tabstrc--recurs-checkno--100-0_2
zerosize;;tabstrc--recurs-checkyes--100-0_2
##set flag########
setreg1;>tabstrc--outbuff--100-0
datawrite1;>tabstrc--recurs-flag--100-0_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--100-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--100-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--100-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--100-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-102-0
goto;>goto--jumper-102-0
setreg1;>goto--jumper-102-0;goto--branch-102-0
s1push1
goto;>driveR--label
zerosize;;goto--jumper-102-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-103-0
goto;>goto--jumper-103-0
dataread1;>@1;goto--branch-103-0
datawrite1;>validflg
zerosize;;goto--jumper-103-0
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--104-0
null;;tabstrc--adrbuff--104-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--104-0
null;;tabstrc--outbuff--104-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--104-0

datawrite1;>tabstrc--recurs-tabbuff--104-0_1
dataread1;;tabstrc--recurs-tabbuff--104-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--104-0_1
dataread1;;tabstrc--recurs-tabbuff_read--104-0_1

setreg2;:R


gotoif;>tabstrc--recurs-checkyes--104-0_1
goto;>tabstrc--recurs-checkno--104-0_1
zerosize;;tabstrc--recurs-checkyes--104-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--104-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--104-0

setreg1;>tabstrc--adrbuff--104-0

datawrite1;>tabstrc--recurs-tabbuff--104-0_2
dataread1;;tabstrc--recurs-tabbuff--104-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--104-0_2
dataread1;;tabstrc--recurs-tabbuff_read--104-0_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--104-0_2
goto;>tabstrc--recurs-checkno--104-0_2
zerosize;;tabstrc--recurs-checkyes--104-0_2
##set flag########
setreg1;>tabstrc--outbuff--104-0
datawrite1;>tabstrc--recurs-flag--104-0_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--104-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--104-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--104-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--104-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-106-0
goto;>goto--jumper-106-0
setreg1;>goto--jumper-106-0;goto--branch-106-0
s1push1
goto;>driveR--label
zerosize;;goto--jumper-106-0
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-107-0
goto;>goto--jumper-107-0
dataread1;>@1;goto--branch-107-0
datawrite1;>validflg
zerosize;;goto--jumper-107-0
#conditional subroutine goto
dataread1;>validflg
dataread2;>@0
gotoif;>goto--branch-109-0
goto;>goto--jumper-109-0
setreg1;>goto--jumper-109-0;goto--branch-109-0
s1push1
goto;>invalid--label
zerosize;;goto--jumper-109-0
#goto 
goto;>main--label
#label
zerosize;;driveA--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-117-0
goto;>goto--jumper-117-0
setreg1;>goto--jumper-117-0;goto--branch-117-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-117-0
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-119-0
goto;>goto--branch-119-0
goto;>flow--con-x-1;goto--branch-119-0

zerosize;;goto--jumper-119-0
#val (used with set to change variable value during runtime.)
setreg1;:A
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-1
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-127-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-127-0
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-128-0;uiter-loopback-128-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-128-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-128-0
gotoif;>uiter-loopback-128-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-129-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-129-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-132-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-132-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;driveB--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-141-0
goto;>goto--branch-141-0
goto;>flow--con-x-2;goto--branch-141-0

zerosize;;goto--jumper-141-0
#val (used with set to change variable value during runtime.)
setreg1;:B
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-2
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-149-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-149-0
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-150-0;uiter-loopback-150-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-150-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-150-0
gotoif;>uiter-loopback-150-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-151-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-151-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-154-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-154-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;driveR--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-163-0
goto;>goto--jumper-163-0
setreg1;>goto--jumper-163-0;goto--branch-163-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-163-0
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-165-0
goto;>goto--branch-165-0
goto;>flow--con-x-3;goto--branch-165-0

zerosize;;goto--jumper-165-0
#val (used with set to change variable value during runtime.)
setreg1;:R
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-3
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-174-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-174-0
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-175-0;uiter-loopback-175-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-175-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-175-0
gotoif;>uiter-loopback-175-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-176-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-176-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-179-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-179-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list--label
#conditional subroutine goto
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-186-0
goto;>goto--jumper-186-0
setreg1;>goto--jumper-186-0;goto--branch-186-0
s1push1
goto;>directory_list_R--label
zerosize;;goto--jumper-186-0
#conditional subroutine goto
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-187-0
goto;>goto--jumper-187-0
setreg1;>goto--jumper-187-0;goto--branch-187-0
s1push1
goto;>directory_list_B--label
zerosize;;goto--jumper-187-0
#conditional subroutine goto
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-188-0
goto;>goto--jumper-188-0
setreg1;>goto--jumper-188-0;goto--branch-188-0
s1push1
goto;>directory_list_A--label
zerosize;;goto--jumper-188-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_A--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:A
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-193-0;uiter-loopback-193-0
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-193-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-193-0
gotoif;>uiter-loopback-193-0

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-196-0;uiter-loopback-196-0
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-196-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-196-0
gotoif;>uiter-loopback-196-0

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-198-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-198-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_B--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:B
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-203-0;uiter-loopback-203-0
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-203-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-203-0
gotoif;>uiter-loopback-203-0

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-206-0;uiter-loopback-206-0
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-206-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-206-0
gotoif;>uiter-loopback-206-0

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-208-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-208-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_R--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-213-0;uiter-loopback-213-0
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-213-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-213-0
gotoif;>uiter-loopback-213-0

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-216-0;uiter-loopback-216-0
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-216-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-216-0
gotoif;>uiter-loopback-216-0

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-218-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-218-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;invalid--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-229-0
goto;>goto--jumper-229-0
setreg1;>goto--jumper-229-0;goto--branch-229-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-229-0
#Set text colors
dataread1;>*++0---
iowrite1;>io.textcolor
#conditional flow control begin
dataread1;>cp.size
dataread2;>@2
gotoifless;>goto--branch-232-0
goto;>goto--jumper-232-0
goto;>flow--con-x-4;goto--branch-232-0

zerosize;;goto--jumper-232-0
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>@1
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--235-0
dataread1;;tabr--adrbuff--235-0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>invalid_charcheck
#conditional flow control begin
dataread1;>invalid_charcheck
dataread2;>::
gotoif;>goto--jumper-237-0
goto;>goto--branch-237-0
goto;>flow--con-x-5;goto--branch-237-0

zerosize;;goto--jumper-237-0
#prline
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:N
fopwri1;:o
fopwri1;:t
fopwri1;:\s
fopwri1;:V
fopwri1;:a
fopwri1;:l
fopwri1;:i
fopwri1;:d
fopwri1;:.
fopwri1;:\s
fopwri1;:s
fopwri1;:e
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:d
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:s
fopwri1;:'
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-5
zerosize;;flow--con-x-4
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopset1;>io.ttywr
#conditional set
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-245-0
goto;>goto--jumper-245-0
dataread1;>:0;goto--branch-245-0
datawrite1;>driveref
zerosize;;goto--jumper-245-0
#conditional set
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-246-0
goto;>goto--jumper-246-0
dataread1;>:1;goto--branch-246-0
datawrite1;>driveref
zerosize;;goto--jumper-246-0
#conditional set
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-247-0
goto;>goto--jumper-247-0
dataread1;>:2;goto--branch-247-0
datawrite1;>driveref
zerosize;;goto--jumper-247-0
#get(1) (may be used with set, or asm code)
dataread1;>driveref
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #249-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '249-0' 
#vdin
fopset1;>vdi.cli.in
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-251-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-251-0
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-252-0;uiter-loopback-252-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-252-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-252-0
gotoif;>uiter-loopback-252-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-253-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-253-0
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-257-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-257-0
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-258-0;uiter-loopback-258-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-258-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-258-0
gotoif;>uiter-loopback-258-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-259-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-259-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-261-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-261-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;extcheck--label
#return from subroutine.
s1pop1
gotoreg1
#subtract (2op math)
dataread1;>cp.size
dataread2;>@4
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extoffset
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>extoffset
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--274-0
null;;tabstrc--adrbuff--274-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--274-0
null;;tabstrc--outbuff--274-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--274-0

datawrite1;>tabstrc--recurs-tabbuff--274-0_1
dataread1;;tabstrc--recurs-tabbuff--274-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--274-0_1
dataread1;;tabstrc--recurs-tabbuff_read--274-0_1

setreg2;:.


gotoif;>tabstrc--recurs-checkyes--274-0_1
goto;>tabstrc--recurs-checkno--274-0_1
zerosize;;tabstrc--recurs-checkyes--274-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--274-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--274-0

setreg1;>tabstrc--adrbuff--274-0

datawrite1;>tabstrc--recurs-tabbuff--274-0_2
dataread1;;tabstrc--recurs-tabbuff--274-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--274-0_2
dataread1;;tabstrc--recurs-tabbuff_read--274-0_2

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--274-0_2
goto;>tabstrc--recurs-checkno--274-0_2
zerosize;;tabstrc--recurs-checkyes--274-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--274-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--274-0

setreg1;>tabstrc--adrbuff--274-0

datawrite1;>tabstrc--recurs-tabbuff--274-0_3
dataread1;;tabstrc--recurs-tabbuff--274-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--274-0_3
dataread1;;tabstrc--recurs-tabbuff_read--274-0_3

setreg2;:x


gotoif;>tabstrc--recurs-checkyes--274-0_3
goto;>tabstrc--recurs-checkno--274-0_3
zerosize;;tabstrc--recurs-checkyes--274-0_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--274-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--274-0

setreg1;>tabstrc--adrbuff--274-0

datawrite1;>tabstrc--recurs-tabbuff--274-0_4
dataread1;;tabstrc--recurs-tabbuff--274-0_4
datawrite1;>tabstrc--recurs-tabbuff_read--274-0_4
dataread1;;tabstrc--recurs-tabbuff_read--274-0_4

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--274-0_4
goto;>tabstrc--recurs-checkno--274-0_4
zerosize;;tabstrc--recurs-checkyes--274-0_4
##set flag########
setreg1;>tabstrc--outbuff--274-0
datawrite1;>tabstrc--recurs-flag--274-0_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--274-0_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274-0_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--274-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--274-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;cmd_run_send_newline--label
#conditional flow control begin
dataread1;>extflg
dataread2;>$false
gotoif;>goto--jumper-281-0
goto;>goto--branch-281-0
goto;>flow--con-x-6;goto--branch-281-0

zerosize;;goto--jumper-281-0
#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-6
#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_setup--label
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_char_exec--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--300-0
dataread1;;tabr--adrbuff--300-0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_s_tmp
#conditional flow control begin
dataread1;>run_tobuffer_flg
dataread2;>@0
gotoif;>goto--jumper-302-0
goto;>goto--branch-302-0
goto;>flow--con-x-7;goto--branch-302-0

zerosize;;goto--jumper-302-0
#conditional set
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-303-0
goto;>goto--jumper-303-0
dataread1;>@1;goto--branch-303-0
datawrite1;>run_tobuffer_flg
zerosize;;goto--jumper-303-0
#conditional return
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-304-0
goto;>goto--jumper-304-0
s1pop1;;goto--branch-304-0
gotoreg1
zerosize;;goto--jumper-304-0
#get(1) (may be used with set, or asm code)
dataread1;>run_s_tmp
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #307-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '307-0' 
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-7
#buffer 2 head write
dataread1;>run_s_tmp
iowrite1;>buffer.2.write.head
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--315-0
dataread1;;tabr--adrbuff--315-0
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #316-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '316-0' 
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;pattern_print_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--320-0
dataread1;;tabr--adrbuff--320-0
iowrite1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;version--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-324-0
s1push1
goto;>splash--label
zerosize;;goto--jumper-324-0
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#prline
fopwri1;:\s
fopwri1;:C
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:I
fopwri1;:n
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:p
fopwri1;:r
fopwri1;:e
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:\s
fopwri1;:v
fopwri1;:2
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;vdi--label
#val (used with set to change variable value during runtime.)
setreg1;10x1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #334-0
iowrite1;>vdi.cli.status#SSTNPL Source Line: '334-0' 
#Upward range iterator
dataread1;>@4
datawrite1;>vdi_iter
setreg1;>uiter-retpos-336-0;uiter-loopback-336-0
s1push1
goto;>vdi_buffiter--label
dataread1;>vdi_iter;uiter-retpos-336-0
setreg2;10x1
add
datawrite1;>vdi_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-336-0
gotoif;>uiter-loopback-336-0

#val (used with set to change variable value during runtime.)
setreg1;:\n
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #338-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '338-0' 
#goto 
goto;>vdi_outloop--label
#label
zerosize;;vdi_outloop--label
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #345-0
ioread1;>vdi.cli.out#SSTNPL Source Line: '345-0' 
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>vdi_vdioutput_buffer
#conditional return
dataread1;>vdi_vdioutput_buffer
dataread2;>@0
gotoif;>goto--branch-348-0
goto;>goto--jumper-348-0
s1pop1;;goto--branch-348-0
gotoreg1
zerosize;;goto--jumper-348-0
#Dump (character)
dataread1;>vdi_vdioutput_buffer
iowrite1;>io.ttywr
#goto 
goto;>vdi_outloop--label
#label
zerosize;;drives--label
#prline
fopwri1;:A
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:B
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:R
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:H
fopwri1;:a
fopwri1;:r
fopwri1;:d
fopwri1;:w
fopwri1;:a
fopwri1;:r
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:a
fopwri1;:m
fopwri1;:d
fopwri1;:i
fopwri1;:s
fopwri1;:k
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;vdi_buffiter--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>vdi_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--361-0
dataread1;;tabr--adrbuff--361-0
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #362-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '362-0' 
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;help--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#bprinthead2n
fopset1;>buffer.2.write.head
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopset1;>io.ttywr
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;splash--label
#Set text colors
dataread1;>*+++0--
iowrite1;>io.textcolor
#print
fopwri1;:S
#Set text colors
dataread1;>*+++00-
iowrite1;>io.textcolor
#print
fopwri1;:B
#Set text colors
dataread1;>*+++-0-
iowrite1;>io.textcolor
#print
fopwri1;:T
#Set text colors
dataread1;>*+++-00
iowrite1;>io.textcolor
#print
fopwri1;:C
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#print
fopwri1;:V
#Set text colors
dataread1;>*+++0-0
iowrite1;>io.textcolor
#print
fopwri1;:M
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print
fopwri1;:-
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:D
fopwri1;:O
fopwri1;:S
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;shutdown--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-397-0
s1push1
goto;>splash--label
zerosize;;goto--jumper-397-0
#prline
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:u
fopwri1;:t
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:d
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:.
fopwri1;:.
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:d
fopwri1;:o
fopwri1;:n
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#stop (shutdown vm)
stop
#module include: line 405-0: comprompt as cp
includeas;comprompt,cp
#END OF FILE
