#SSTNPL COMPILER v0.3.0
#header
head-rname=command
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "apps/dos/command/command.stnp
null;+++---;*+++---
null;10x1;@1
null;0;cmdflg
null;0;validflg
null;:A;drive
null;0+0---;*0+0---
null;10x0;@0
null;10x3;@3
null;10x0;run_iter
null;:R;:R
null;:B;:B
null;:A;:A
null;10x4;@4
null;:0;driveref
null;0;invalid_charcheck
null;++0---;*++0---
null;10x2;@2
null;::;::
null;:0;:0
null;:1;:1
null;:2;:2
null;0;run_s_tmp
null;0;run_tobuffer_flg
null;:\s;:\s
null;0++---;*0++---
null;0;vdi_vdioutput_buffer
null;10x0;vdi_iter
null;+++0--;*+++0--
null;+++00-;*+++00-
null;+++-0-;*+++-0-
null;+++-00;*+++-00
null;+++--0;*+++--0
null;+++0-0;*+++0-0
#label
null;;startup--label
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#prline
fopwri1;:T
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:?
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:\s
fopwri1;:R
fopwri1;:E
fopwri1;:A
fopwri1;:D
fopwri1;:Y
fopwri1;:.
fopwri1;:\n
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#buffer 2 reset
iowrite1;>buffer.2.reset
#goto 
goto;>main--label
#label
null;;main--label
#Set text colors
dataread1;>*0+0---
iowrite1;>io.textcolor
#Dump (character)
dataread1;>drive
iowrite1;>io.ttywr
#print
fopwri1;::
fopwri1;:\b
fopwri1;:>
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#goto (extra code stores away return address.)
setreg1;>goto--jumper-31
s1push1
goto;>cp.getentry--label
null;;goto--jumper-31
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validflg
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--37
null;;tabstrc--adrbuff--37
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--37
null;;tabstrc--outbuff--37
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--37

datawrite1;>tabstrc--recurs-tabbuff--37_1
dataread1;;tabstrc--recurs-tabbuff--37_1
datawrite1;>tabstrc--recurs-tabbuff_read--37_1
dataread1;;tabstrc--recurs-tabbuff_read--37_1

setreg2;:?


gotoif;>tabstrc--recurs-checkyes--37_1
goto;>tabstrc--recurs-checkno--37_1
null;;tabstrc--recurs-checkyes--37_1
##set flag########
setreg1;>tabstrc--outbuff--37
datawrite1;>tabstrc--recurs-flag--37_1
setreg1;+
datawrite1;;tabstrc--recurs-flag--37_1
#recursionskip endpoint
null;;tabstrc--recurs-checkno--37_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--37
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-39
goto;>goto--jumper-39
setreg1;>goto--jumper-39;goto--branch-39
s1push1
goto;>help--label
null;;goto--jumper-39
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-40
goto;>goto--jumper-40
dataread1;>@1;goto--branch-40
datawrite1;>validflg
null;;goto--jumper-40
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--41
null;;tabstrc--adrbuff--41
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--41
null;;tabstrc--outbuff--41
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--41

datawrite1;>tabstrc--recurs-tabbuff--41_1
dataread1;;tabstrc--recurs-tabbuff--41_1
datawrite1;>tabstrc--recurs-tabbuff_read--41_1
dataread1;;tabstrc--recurs-tabbuff_read--41_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--41_1
goto;>tabstrc--recurs-checkno--41_1
null;;tabstrc--recurs-checkyes--41_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--41
setreg2;+
add
datawrite1;>tabstrc--adrbuff--41

setreg1;>tabstrc--adrbuff--41

datawrite1;>tabstrc--recurs-tabbuff--41_2
dataread1;;tabstrc--recurs-tabbuff--41_2
datawrite1;>tabstrc--recurs-tabbuff_read--41_2
dataread1;;tabstrc--recurs-tabbuff_read--41_2

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--41_2
goto;>tabstrc--recurs-checkno--41_2
null;;tabstrc--recurs-checkyes--41_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--41
setreg2;+
add
datawrite1;>tabstrc--adrbuff--41

setreg1;>tabstrc--adrbuff--41

datawrite1;>tabstrc--recurs-tabbuff--41_3
dataread1;;tabstrc--recurs-tabbuff--41_3
datawrite1;>tabstrc--recurs-tabbuff_read--41_3
dataread1;;tabstrc--recurs-tabbuff_read--41_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--41_3
goto;>tabstrc--recurs-checkno--41_3
null;;tabstrc--recurs-checkyes--41_3
##set flag########
setreg1;>tabstrc--outbuff--41
datawrite1;>tabstrc--recurs-flag--41_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--41_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--41_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--41_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--41_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--41
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-43
goto;>goto--jumper-43
setreg1;>goto--jumper-43;goto--branch-43
s1push1
goto;>vdi--label
null;;goto--jumper-43
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-44
goto;>goto--jumper-44
dataread1;>@1;goto--branch-44
datawrite1;>validflg
null;;goto--jumper-44
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--45
null;;tabstrc--adrbuff--45
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--45
null;;tabstrc--outbuff--45
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--45

datawrite1;>tabstrc--recurs-tabbuff--45_1
dataread1;;tabstrc--recurs-tabbuff--45_1
datawrite1;>tabstrc--recurs-tabbuff_read--45_1
dataread1;;tabstrc--recurs-tabbuff_read--45_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--45_1
goto;>tabstrc--recurs-checkno--45_1
null;;tabstrc--recurs-checkyes--45_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--45
setreg2;+
add
datawrite1;>tabstrc--adrbuff--45

setreg1;>tabstrc--adrbuff--45

datawrite1;>tabstrc--recurs-tabbuff--45_2
dataread1;;tabstrc--recurs-tabbuff--45_2
datawrite1;>tabstrc--recurs-tabbuff_read--45_2
dataread1;;tabstrc--recurs-tabbuff_read--45_2

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--45_2
goto;>tabstrc--recurs-checkno--45_2
null;;tabstrc--recurs-checkyes--45_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--45
setreg2;+
add
datawrite1;>tabstrc--adrbuff--45

setreg1;>tabstrc--adrbuff--45

datawrite1;>tabstrc--recurs-tabbuff--45_3
dataread1;;tabstrc--recurs-tabbuff--45_3
datawrite1;>tabstrc--recurs-tabbuff_read--45_3
dataread1;;tabstrc--recurs-tabbuff_read--45_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--45_3
goto;>tabstrc--recurs-checkno--45_3
null;;tabstrc--recurs-checkyes--45_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--45
setreg2;+
add
datawrite1;>tabstrc--adrbuff--45

setreg1;>tabstrc--adrbuff--45

datawrite1;>tabstrc--recurs-tabbuff--45_4
dataread1;;tabstrc--recurs-tabbuff--45_4
datawrite1;>tabstrc--recurs-tabbuff_read--45_4
dataread1;;tabstrc--recurs-tabbuff_read--45_4

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--45_4
goto;>tabstrc--recurs-checkno--45_4
null;;tabstrc--recurs-checkyes--45_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--45
setreg2;+
add
datawrite1;>tabstrc--adrbuff--45

setreg1;>tabstrc--adrbuff--45

datawrite1;>tabstrc--recurs-tabbuff--45_5
dataread1;;tabstrc--recurs-tabbuff--45_5
datawrite1;>tabstrc--recurs-tabbuff_read--45_5
dataread1;;tabstrc--recurs-tabbuff_read--45_5

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--45_5
goto;>tabstrc--recurs-checkno--45_5
null;;tabstrc--recurs-checkyes--45_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--45
setreg2;+
add
datawrite1;>tabstrc--adrbuff--45

setreg1;>tabstrc--adrbuff--45

datawrite1;>tabstrc--recurs-tabbuff--45_6
dataread1;;tabstrc--recurs-tabbuff--45_6
datawrite1;>tabstrc--recurs-tabbuff_read--45_6
dataread1;;tabstrc--recurs-tabbuff_read--45_6

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--45_6
goto;>tabstrc--recurs-checkno--45_6
null;;tabstrc--recurs-checkyes--45_6
##set flag########
setreg1;>tabstrc--outbuff--45
datawrite1;>tabstrc--recurs-flag--45_6
setreg1;+
datawrite1;;tabstrc--recurs-flag--45_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--45_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--45_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--45_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--45_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--45_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--45_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--45
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-47
goto;>goto--jumper-47
setreg1;>goto--jumper-47;goto--branch-47
s1push1
goto;>drives--label
null;;goto--jumper-47
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-48
goto;>goto--jumper-48
dataread1;>@1;goto--branch-48
datawrite1;>validflg
null;;goto--jumper-48
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--49
null;;tabstrc--adrbuff--49
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--49
null;;tabstrc--outbuff--49
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--49

datawrite1;>tabstrc--recurs-tabbuff--49_1
dataread1;;tabstrc--recurs-tabbuff--49_1
datawrite1;>tabstrc--recurs-tabbuff_read--49_1
dataread1;;tabstrc--recurs-tabbuff_read--49_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--49_1
goto;>tabstrc--recurs-checkno--49_1
null;;tabstrc--recurs-checkyes--49_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--49
setreg2;+
add
datawrite1;>tabstrc--adrbuff--49

setreg1;>tabstrc--adrbuff--49

datawrite1;>tabstrc--recurs-tabbuff--49_2
dataread1;;tabstrc--recurs-tabbuff--49_2
datawrite1;>tabstrc--recurs-tabbuff_read--49_2
dataread1;;tabstrc--recurs-tabbuff_read--49_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--49_2
goto;>tabstrc--recurs-checkno--49_2
null;;tabstrc--recurs-checkyes--49_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--49
setreg2;+
add
datawrite1;>tabstrc--adrbuff--49

setreg1;>tabstrc--adrbuff--49

datawrite1;>tabstrc--recurs-tabbuff--49_3
dataread1;;tabstrc--recurs-tabbuff--49_3
datawrite1;>tabstrc--recurs-tabbuff_read--49_3
dataread1;;tabstrc--recurs-tabbuff_read--49_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--49_3
goto;>tabstrc--recurs-checkno--49_3
null;;tabstrc--recurs-checkyes--49_3
##set flag########
setreg1;>tabstrc--outbuff--49
datawrite1;>tabstrc--recurs-flag--49_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--49_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--49_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--49_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--49_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--49
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-51
goto;>goto--jumper-51
setreg1;>goto--jumper-51;goto--branch-51
s1push1
goto;>version--label
null;;goto--jumper-51
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-52
goto;>goto--jumper-52
dataread1;>@1;goto--branch-52
datawrite1;>validflg
null;;goto--jumper-52
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--53
null;;tabstrc--adrbuff--53
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--53
null;;tabstrc--outbuff--53
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--53

datawrite1;>tabstrc--recurs-tabbuff--53_1
dataread1;;tabstrc--recurs-tabbuff--53_1
datawrite1;>tabstrc--recurs-tabbuff_read--53_1
dataread1;;tabstrc--recurs-tabbuff_read--53_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--53_1
goto;>tabstrc--recurs-checkno--53_1
null;;tabstrc--recurs-checkyes--53_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--53
setreg2;+
add
datawrite1;>tabstrc--adrbuff--53

setreg1;>tabstrc--adrbuff--53

datawrite1;>tabstrc--recurs-tabbuff--53_2
dataread1;;tabstrc--recurs-tabbuff--53_2
datawrite1;>tabstrc--recurs-tabbuff_read--53_2
dataread1;;tabstrc--recurs-tabbuff_read--53_2

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--53_2
goto;>tabstrc--recurs-checkno--53_2
null;;tabstrc--recurs-checkyes--53_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--53
setreg2;+
add
datawrite1;>tabstrc--adrbuff--53

setreg1;>tabstrc--adrbuff--53

datawrite1;>tabstrc--recurs-tabbuff--53_3
dataread1;;tabstrc--recurs-tabbuff--53_3
datawrite1;>tabstrc--recurs-tabbuff_read--53_3
dataread1;;tabstrc--recurs-tabbuff_read--53_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--53_3
goto;>tabstrc--recurs-checkno--53_3
null;;tabstrc--recurs-checkyes--53_3
##set flag########
setreg1;>tabstrc--outbuff--53
datawrite1;>tabstrc--recurs-flag--53_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--53_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--53_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--53_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--53_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--53
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-55
goto;>goto--jumper-55
setreg1;>goto--jumper-55;goto--branch-55
s1push1
goto;>directory_list--label
null;;goto--jumper-55
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-56
goto;>goto--jumper-56
dataread1;>@1;goto--branch-56
datawrite1;>validflg
null;;goto--jumper-56
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--57
null;;tabstrc--adrbuff--57
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--57
null;;tabstrc--outbuff--57
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_1
dataread1;;tabstrc--recurs-tabbuff--57_1
datawrite1;>tabstrc--recurs-tabbuff_read--57_1
dataread1;;tabstrc--recurs-tabbuff_read--57_1

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--57_1
goto;>tabstrc--recurs-checkno--57_1
null;;tabstrc--recurs-checkyes--57_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_2
dataread1;;tabstrc--recurs-tabbuff--57_2
datawrite1;>tabstrc--recurs-tabbuff_read--57_2
dataread1;;tabstrc--recurs-tabbuff_read--57_2

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--57_2
goto;>tabstrc--recurs-checkno--57_2
null;;tabstrc--recurs-checkyes--57_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_3
dataread1;;tabstrc--recurs-tabbuff--57_3
datawrite1;>tabstrc--recurs-tabbuff_read--57_3
dataread1;;tabstrc--recurs-tabbuff_read--57_3

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--57_3
goto;>tabstrc--recurs-checkno--57_3
null;;tabstrc--recurs-checkyes--57_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_4
dataread1;;tabstrc--recurs-tabbuff--57_4
datawrite1;>tabstrc--recurs-tabbuff_read--57_4
dataread1;;tabstrc--recurs-tabbuff_read--57_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--57_4
goto;>tabstrc--recurs-checkno--57_4
null;;tabstrc--recurs-checkyes--57_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_5
dataread1;;tabstrc--recurs-tabbuff--57_5
datawrite1;>tabstrc--recurs-tabbuff_read--57_5
dataread1;;tabstrc--recurs-tabbuff_read--57_5

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--57_5
goto;>tabstrc--recurs-checkno--57_5
null;;tabstrc--recurs-checkyes--57_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_6
dataread1;;tabstrc--recurs-tabbuff--57_6
datawrite1;>tabstrc--recurs-tabbuff_read--57_6
dataread1;;tabstrc--recurs-tabbuff_read--57_6

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--57_6
goto;>tabstrc--recurs-checkno--57_6
null;;tabstrc--recurs-checkyes--57_6
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_7
dataread1;;tabstrc--recurs-tabbuff--57_7
datawrite1;>tabstrc--recurs-tabbuff_read--57_7
dataread1;;tabstrc--recurs-tabbuff_read--57_7

setreg2;:w


gotoif;>tabstrc--recurs-checkyes--57_7
goto;>tabstrc--recurs-checkno--57_7
null;;tabstrc--recurs-checkyes--57_7
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--57
setreg2;+
add
datawrite1;>tabstrc--adrbuff--57

setreg1;>tabstrc--adrbuff--57

datawrite1;>tabstrc--recurs-tabbuff--57_8
dataread1;;tabstrc--recurs-tabbuff--57_8
datawrite1;>tabstrc--recurs-tabbuff_read--57_8
dataread1;;tabstrc--recurs-tabbuff_read--57_8

setreg2;:n


gotoif;>tabstrc--recurs-checkyes--57_8
goto;>tabstrc--recurs-checkno--57_8
null;;tabstrc--recurs-checkyes--57_8
##set flag########
setreg1;>tabstrc--outbuff--57
datawrite1;>tabstrc--recurs-flag--57_8
setreg1;+
datawrite1;;tabstrc--recurs-flag--57_8
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_8
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_7
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_6
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_5
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_4
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_3
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--57_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--57
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-59
goto;>goto--jumper-59
setreg1;>goto--jumper-59;goto--branch-59
s1push1
goto;>shutdown--label
null;;goto--jumper-59
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-60
goto;>goto--jumper-60
dataread1;>@1;goto--branch-60
datawrite1;>validflg
null;;goto--jumper-60
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--63
null;;tabstrc--adrbuff--63
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--63
null;;tabstrc--outbuff--63
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--63

datawrite1;>tabstrc--recurs-tabbuff--63_1
dataread1;;tabstrc--recurs-tabbuff--63_1
datawrite1;>tabstrc--recurs-tabbuff_read--63_1
dataread1;;tabstrc--recurs-tabbuff_read--63_1

setreg2;:a


gotoif;>tabstrc--recurs-checkyes--63_1
goto;>tabstrc--recurs-checkno--63_1
null;;tabstrc--recurs-checkyes--63_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--63
setreg2;+
add
datawrite1;>tabstrc--adrbuff--63

setreg1;>tabstrc--adrbuff--63

datawrite1;>tabstrc--recurs-tabbuff--63_2
dataread1;;tabstrc--recurs-tabbuff--63_2
datawrite1;>tabstrc--recurs-tabbuff_read--63_2
dataread1;;tabstrc--recurs-tabbuff_read--63_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--63_2
goto;>tabstrc--recurs-checkno--63_2
null;;tabstrc--recurs-checkyes--63_2
##set flag########
setreg1;>tabstrc--outbuff--63
datawrite1;>tabstrc--recurs-flag--63_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--63_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--63_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--63_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--63
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-65
goto;>goto--jumper-65
setreg1;>goto--jumper-65;goto--branch-65
s1push1
goto;>driveA--label
null;;goto--jumper-65
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-66
goto;>goto--jumper-66
dataread1;>@1;goto--branch-66
datawrite1;>validflg
null;;goto--jumper-66
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--67
null;;tabstrc--adrbuff--67
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--67
null;;tabstrc--outbuff--67
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--67

datawrite1;>tabstrc--recurs-tabbuff--67_1
dataread1;;tabstrc--recurs-tabbuff--67_1
datawrite1;>tabstrc--recurs-tabbuff_read--67_1
dataread1;;tabstrc--recurs-tabbuff_read--67_1

setreg2;:A


gotoif;>tabstrc--recurs-checkyes--67_1
goto;>tabstrc--recurs-checkno--67_1
null;;tabstrc--recurs-checkyes--67_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--67
setreg2;+
add
datawrite1;>tabstrc--adrbuff--67

setreg1;>tabstrc--adrbuff--67

datawrite1;>tabstrc--recurs-tabbuff--67_2
dataread1;;tabstrc--recurs-tabbuff--67_2
datawrite1;>tabstrc--recurs-tabbuff_read--67_2
dataread1;;tabstrc--recurs-tabbuff_read--67_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--67_2
goto;>tabstrc--recurs-checkno--67_2
null;;tabstrc--recurs-checkyes--67_2
##set flag########
setreg1;>tabstrc--outbuff--67
datawrite1;>tabstrc--recurs-flag--67_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--67_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--67_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--67_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--67
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-69
goto;>goto--jumper-69
setreg1;>goto--jumper-69;goto--branch-69
s1push1
goto;>driveA--label
null;;goto--jumper-69
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-70
goto;>goto--jumper-70
dataread1;>@1;goto--branch-70
datawrite1;>validflg
null;;goto--jumper-70
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--72
null;;tabstrc--adrbuff--72
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--72
null;;tabstrc--outbuff--72
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_1
dataread1;;tabstrc--recurs-tabbuff--72_1
datawrite1;>tabstrc--recurs-tabbuff_read--72_1
dataread1;;tabstrc--recurs-tabbuff_read--72_1

setreg2;:b


gotoif;>tabstrc--recurs-checkyes--72_1
goto;>tabstrc--recurs-checkno--72_1
null;;tabstrc--recurs-checkyes--72_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--72
setreg2;+
add
datawrite1;>tabstrc--adrbuff--72

setreg1;>tabstrc--adrbuff--72

datawrite1;>tabstrc--recurs-tabbuff--72_2
dataread1;;tabstrc--recurs-tabbuff--72_2
datawrite1;>tabstrc--recurs-tabbuff_read--72_2
dataread1;;tabstrc--recurs-tabbuff_read--72_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--72_2
goto;>tabstrc--recurs-checkno--72_2
null;;tabstrc--recurs-checkyes--72_2
##set flag########
setreg1;>tabstrc--outbuff--72
datawrite1;>tabstrc--recurs-flag--72_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--72_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--72_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--72_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--72
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-74
goto;>goto--jumper-74
setreg1;>goto--jumper-74;goto--branch-74
s1push1
goto;>driveB--label
null;;goto--jumper-74
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-75
goto;>goto--jumper-75
dataread1;>@1;goto--branch-75
datawrite1;>validflg
null;;goto--jumper-75
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--76
null;;tabstrc--adrbuff--76
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--76
null;;tabstrc--outbuff--76
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_1
dataread1;;tabstrc--recurs-tabbuff--76_1
datawrite1;>tabstrc--recurs-tabbuff_read--76_1
dataread1;;tabstrc--recurs-tabbuff_read--76_1

setreg2;:B


gotoif;>tabstrc--recurs-checkyes--76_1
goto;>tabstrc--recurs-checkno--76_1
null;;tabstrc--recurs-checkyes--76_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--76
setreg2;+
add
datawrite1;>tabstrc--adrbuff--76

setreg1;>tabstrc--adrbuff--76

datawrite1;>tabstrc--recurs-tabbuff--76_2
dataread1;;tabstrc--recurs-tabbuff--76_2
datawrite1;>tabstrc--recurs-tabbuff_read--76_2
dataread1;;tabstrc--recurs-tabbuff_read--76_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--76_2
goto;>tabstrc--recurs-checkno--76_2
null;;tabstrc--recurs-checkyes--76_2
##set flag########
setreg1;>tabstrc--outbuff--76
datawrite1;>tabstrc--recurs-flag--76_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--76_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--76_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--76
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-78
goto;>goto--jumper-78
setreg1;>goto--jumper-78;goto--branch-78
s1push1
goto;>driveB--label
null;;goto--jumper-78
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-79
goto;>goto--jumper-79
dataread1;>@1;goto--branch-79
datawrite1;>validflg
null;;goto--jumper-79
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--81
null;;tabstrc--adrbuff--81
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--81
null;;tabstrc--outbuff--81
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--81

datawrite1;>tabstrc--recurs-tabbuff--81_1
dataread1;;tabstrc--recurs-tabbuff--81_1
datawrite1;>tabstrc--recurs-tabbuff_read--81_1
dataread1;;tabstrc--recurs-tabbuff_read--81_1

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--81_1
goto;>tabstrc--recurs-checkno--81_1
null;;tabstrc--recurs-checkyes--81_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--81
setreg2;+
add
datawrite1;>tabstrc--adrbuff--81

setreg1;>tabstrc--adrbuff--81

datawrite1;>tabstrc--recurs-tabbuff--81_2
dataread1;;tabstrc--recurs-tabbuff--81_2
datawrite1;>tabstrc--recurs-tabbuff_read--81_2
dataread1;;tabstrc--recurs-tabbuff_read--81_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--81_2
goto;>tabstrc--recurs-checkno--81_2
null;;tabstrc--recurs-checkyes--81_2
##set flag########
setreg1;>tabstrc--outbuff--81
datawrite1;>tabstrc--recurs-flag--81_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--81_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--81_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--81_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--81
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-83
goto;>goto--jumper-83
setreg1;>goto--jumper-83;goto--branch-83
s1push1
goto;>driveR--label
null;;goto--jumper-83
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-84
goto;>goto--jumper-84
dataread1;>@1;goto--branch-84
datawrite1;>validflg
null;;goto--jumper-84
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabstrc--adrbuff--85
null;;tabstrc--adrbuff--85
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--85
null;;tabstrc--outbuff--85
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--85

datawrite1;>tabstrc--recurs-tabbuff--85_1
dataread1;;tabstrc--recurs-tabbuff--85_1
datawrite1;>tabstrc--recurs-tabbuff_read--85_1
dataread1;;tabstrc--recurs-tabbuff_read--85_1

setreg2;:R


gotoif;>tabstrc--recurs-checkyes--85_1
goto;>tabstrc--recurs-checkno--85_1
null;;tabstrc--recurs-checkyes--85_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--85
setreg2;+
add
datawrite1;>tabstrc--adrbuff--85

setreg1;>tabstrc--adrbuff--85

datawrite1;>tabstrc--recurs-tabbuff--85_2
dataread1;;tabstrc--recurs-tabbuff--85_2
datawrite1;>tabstrc--recurs-tabbuff_read--85_2
dataread1;;tabstrc--recurs-tabbuff_read--85_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--85_2
goto;>tabstrc--recurs-checkno--85_2
null;;tabstrc--recurs-checkyes--85_2
##set flag########
setreg1;>tabstrc--outbuff--85
datawrite1;>tabstrc--recurs-flag--85_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--85_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--85_2
#recursionskip endpoint
null;;tabstrc--recurs-checkno--85_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--85
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-87
goto;>goto--jumper-87
setreg1;>goto--jumper-87;goto--branch-87
s1push1
goto;>driveR--label
null;;goto--jumper-87
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-88
goto;>goto--jumper-88
dataread1;>@1;goto--branch-88
datawrite1;>validflg
null;;goto--jumper-88
#conditional subroutine goto
dataread1;>validflg
dataread2;>@0
gotoif;>goto--branch-90
goto;>goto--jumper-90
setreg1;>goto--jumper-90;goto--branch-90
s1push1
goto;>invalid--label
null;;goto--jumper-90
#goto 
goto;>main--label
#label
null;;driveA--label
#val (used with set to change variable value during runtime.)
setreg1;:A
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#conditional return
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--branch-98
goto;>goto--jumper-98
s1pop1;;goto--branch-98
gotoreg1
null;;goto--jumper-98
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-100
s1push1
goto;>run_send_setup--label
null;;goto--jumper-100
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-101;uiter-loopback-101
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-101
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-101
gotoif;>uiter-loopback-101

#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-104
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-104
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveB--label
#val (used with set to change variable value during runtime.)
setreg1;:B
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#conditional return
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--branch-110
goto;>goto--jumper-110
s1pop1;;goto--branch-110
gotoreg1
null;;goto--jumper-110
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-112
s1push1
goto;>run_send_setup--label
null;;goto--jumper-112
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-113;uiter-loopback-113
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-113
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-113
gotoif;>uiter-loopback-113

#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-116
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-116
#return from subroutine.
s1pop1
gotoreg1
#label
null;;driveR--label
#val (used with set to change variable value during runtime.)
setreg1;:R
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#conditional return
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--branch-123
goto;>goto--jumper-123
s1pop1;;goto--branch-123
gotoreg1
null;;goto--jumper-123
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-125
s1push1
goto;>run_send_setup--label
null;;goto--jumper-125
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-126;uiter-loopback-126
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-126
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-126
gotoif;>uiter-loopback-126

#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-129
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-129
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list--label
#conditional subroutine goto
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-134
goto;>goto--jumper-134
setreg1;>goto--jumper-134;goto--branch-134
s1push1
goto;>directory_list_R--label
null;;goto--jumper-134
#conditional subroutine goto
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-135
goto;>goto--jumper-135
setreg1;>goto--jumper-135;goto--branch-135
s1push1
goto;>directory_list_B--label
null;;goto--jumper-135
#conditional subroutine goto
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-136
goto;>goto--jumper-136
setreg1;>goto--jumper-136;goto--branch-136
s1push1
goto;>directory_list_A--label
null;;goto--jumper-136
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_A--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:A
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-141;uiter-loopback-141
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-141
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-141
gotoif;>uiter-loopback-141

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-144;uiter-loopback-144
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-144
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-144
gotoif;>uiter-loopback-144

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-146
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-146
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_B--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:B
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-151;uiter-loopback-151
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-151
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-151
gotoif;>uiter-loopback-151

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-154;uiter-loopback-154
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-154
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-154
gotoif;>uiter-loopback-154

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-156
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-156
#return from subroutine.
s1pop1
gotoreg1
#label
null;;directory_list_R--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-161;uiter-loopback-161
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-161
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-161
gotoif;>uiter-loopback-161

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-164;uiter-loopback-164
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-164
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-164
gotoif;>uiter-loopback-164

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-166
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-166
#return from subroutine.
s1pop1
gotoreg1
#label
null;;invalid--label
#Set text colors
dataread1;>*++0---
iowrite1;>io.textcolor
#conditional goto
dataread1;>cp.size
dataread2;>@2
gotoifless;>goto--branch-172
goto;>goto--jumper-172
setreg1;>goto--jumper-172;goto--branch-172
goto;>run_command--label
null;;goto--jumper-172
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>@1
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--174
dataread1;;tabr--adrbuff--174
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>invalid_charcheck
#conditional goto
dataread1;>invalid_charcheck
dataread2;>::
gotoif;>goto--jumper-176
goto;>goto--branch-176
setreg1;>goto--jumper-176;goto--branch-176
goto;>run_command--label
null;;goto--jumper-176
#prline
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:N
fopwri1;:o
fopwri1;:t
fopwri1;:\s
fopwri1;:V
fopwri1;:a
fopwri1;:l
fopwri1;:i
fopwri1;:d
fopwri1;:.
fopwri1;:\s
fopwri1;:s
fopwri1;:e
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:d
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:s
fopwri1;:'
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_command--label
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopset1;>io.ttywr
#conditional set
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-183
goto;>goto--jumper-183
dataread1;>:0;goto--branch-183
datawrite1;>driveref
null;;goto--jumper-183
#conditional set
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-184
goto;>goto--jumper-184
dataread1;>:1;goto--branch-184
datawrite1;>driveref
null;;goto--jumper-184
#conditional set
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-185
goto;>goto--jumper-185
dataread1;>:2;goto--branch-185
datawrite1;>driveref
null;;goto--jumper-185
#get(1) (may be used with set, or asm code)
dataread1;>driveref
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #187
iowrite1;>vdi.cli.in#SSTNPL Source Line: '187' 
#vdin
fopset1;>vdi.cli.in
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-189
s1push1
goto;>run_send_setup--label
null;;goto--jumper-189
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-190;uiter-loopback-190
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-190
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-190
gotoif;>uiter-loopback-190

#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-195
s1push1
goto;>run_send_setup--label
null;;goto--jumper-195
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-196;uiter-loopback-196
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-196
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-196
gotoif;>uiter-loopback-196

#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-199
s1push1
goto;>vdi_outloop--label
null;;goto--jumper-199
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_setup--label
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_char_exec--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--212
dataread1;;tabr--adrbuff--212
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_s_tmp
#conditional goto
dataread1;>run_tobuffer_flg
dataread2;>@1
gotoif;>goto--branch-214
goto;>goto--jumper-214
setreg1;>goto--jumper-214;goto--branch-214
goto;>run_send_doredir--label
null;;goto--jumper-214
#conditional set
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-215
goto;>goto--jumper-215
dataread1;>@1;goto--branch-215
datawrite1;>run_tobuffer_flg
null;;goto--jumper-215
#conditional return
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--branch-216
goto;>goto--jumper-216
s1pop1;;goto--branch-216
gotoreg1
null;;goto--jumper-216
#get(1) (may be used with set, or asm code)
dataread1;>run_s_tmp
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #219
iowrite1;>vdi.cli.in#SSTNPL Source Line: '219' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_doredir--label
#buffer 2 head write
dataread1;>run_s_tmp
iowrite1;>buffer.2.write.head
#return from subroutine.
s1pop1
gotoreg1
#label
null;;run_send_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--227
dataread1;;tabr--adrbuff--227
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #228
iowrite1;>vdi.cli.in#SSTNPL Source Line: '228' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;pattern_print_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--232
dataread1;;tabr--adrbuff--232
iowrite1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;version--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-236
s1push1
goto;>splash--label
null;;goto--jumper-236
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#prline
fopwri1;:\s
fopwri1;:C
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:I
fopwri1;:n
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:p
fopwri1;:r
fopwri1;:e
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:\s
fopwri1;:v
fopwri1;:2
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;vdi--label
#val (used with set to change variable value during runtime.)
setreg1;10x1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #246
iowrite1;>vdi.cli.status#SSTNPL Source Line: '246' 
#Upward range iterator
dataread1;>@4
datawrite1;>vdi_iter
setreg1;>uiter-retpos-248;uiter-loopback-248
s1push1
goto;>vdi_buffiter--label
dataread1;>vdi_iter;uiter-retpos-248
setreg2;10x1
add
datawrite1;>vdi_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-248
gotoif;>uiter-loopback-248

#val (used with set to change variable value during runtime.)
setreg1;:\n
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #250
iowrite1;>vdi.cli.in#SSTNPL Source Line: '250' 
#goto 
goto;>vdi_outloop--label
#label
null;;vdi_outloop--label
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #257
ioread1;>vdi.cli.out#SSTNPL Source Line: '257' 
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>vdi_vdioutput_buffer
#conditional return
dataread1;>vdi_vdioutput_buffer
dataread2;>@0
gotoif;>goto--branch-260
goto;>goto--jumper-260
s1pop1;;goto--branch-260
gotoreg1
null;;goto--jumper-260
#Dump (character)
dataread1;>vdi_vdioutput_buffer
iowrite1;>io.ttywr
#goto 
goto;>vdi_outloop--label
#label
null;;drives--label
#prline
fopwri1;:A
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:B
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:R
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:H
fopwri1;:a
fopwri1;:r
fopwri1;:d
fopwri1;:w
fopwri1;:a
fopwri1;:r
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:a
fopwri1;:m
fopwri1;:d
fopwri1;:i
fopwri1;:s
fopwri1;:k
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
null;;vdi_buffiter--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>vdi_iter
add
setreg2;10x1
add
setreg2;>cp.buffer--table
add
datawrite1;>tabr--adrbuff--273
dataread1;;tabr--adrbuff--273
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #274
iowrite1;>vdi.cli.in#SSTNPL Source Line: '274' 
#return from subroutine.
s1pop1
gotoreg1
#label
null;;help--label
#bprinthead2n
fopset1;>buffer.2.write.head
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopset1;>io.ttywr
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
null;;splash--label
#Set text colors
dataread1;>*+++0--
iowrite1;>io.textcolor
#print
fopwri1;:S
#Set text colors
dataread1;>*+++00-
iowrite1;>io.textcolor
#print
fopwri1;:B
#Set text colors
dataread1;>*+++-0-
iowrite1;>io.textcolor
#print
fopwri1;:T
#Set text colors
dataread1;>*+++-00
iowrite1;>io.textcolor
#print
fopwri1;:C
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#print
fopwri1;:V
#Set text colors
dataread1;>*+++0-0
iowrite1;>io.textcolor
#print
fopwri1;:M
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print
fopwri1;:-
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:D
fopwri1;:O
fopwri1;:S
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#return from subroutine.
s1pop1
gotoreg1
#label
null;;shutdown--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-308
s1push1
goto;>splash--label
null;;goto--jumper-308
#prline
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:u
fopwri1;:t
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:d
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:.
fopwri1;:.
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:d
fopwri1;:o
fopwri1;:n
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#stop (shutdown vm)
stop
#module include: line 316: comprompt as cp
includeas;comprompt,cp
#END OF FILE
