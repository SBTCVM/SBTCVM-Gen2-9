#SSTNPL COMPILER v0.4.0
#header
head-rname=command
head-nspin=stdnsp
fopset1;>io.ttywr
fopset2;>io.packart
#stnp source file: (autogenerated from) "apps/dos/command/command.stnp
null;0;sysbak
null;10x1;$true
null;10x1;@1
null;10x0;$false
null;+++---;*+++---
null;0;cmdflg
null;0;validflg
null;:A;drive
null;0+0---;*0+0---
null;10x0;@0
null;10x4;@4
null;10x3;@3
null;10x0;run_iter
null;:R;:R
null;:B;:B
null;:A;:A
null;:0;driveref
null;0;invalid_charcheck
null;0;extflg
null;0;extoffset
null;++0---;*++0---
null;10x2;@2
null;::;::
null;:0;:0
null;:1;:1
null;:2;:2
null;0;run_s_tmp
null;0;run_tobuffer_flg
null;:\s;:\s
null;0++---;*0++---
null;0;vdi_vdioutput_buffer
null;10x0;vdi_iter
null;+++0--;*+++0--
null;+++00-;*+++00-
null;+++-0-;*+++-0-
null;+++-00;*+++-00
null;+++--0;*+++--0
null;+++0-0;*+++0-0
#conditional goto
dataread1;>sysbak
dataread2;>$true
gotoif;>goto--branch-4-0
goto;>goto--jumper-4-0
setreg1;>goto--jumper-4-0;goto--branch-4-0
goto;>startup--label
zerosize;;goto--jumper-4-0
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#label
zerosize;;startup--label
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-14-0
goto;>goto--jumper-14-0
setreg1;>goto--jumper-14-0;goto--branch-14-0
s1push1
goto;>version--label
zerosize;;goto--jumper-14-0
#conditional subroutine goto
dataread1;>sysbak
dataread2;>$false
gotoif;>goto--branch-15-0
goto;>goto--jumper-15-0
setreg1;>goto--jumper-15-0;goto--branch-15-0
s1push1
goto;>help_ready_splash--label
zerosize;;goto--jumper-15-0
#val (used with set to change variable value during runtime.)
setreg1;10x1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>sysbak
#vdi mode set
dataread1;>@1
iowrite1;>vdi.cli.status
#val (used with set to change variable value during runtime.)
setreg1;10x70
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.max
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cp.clearbuffer
#buffer 2 reset
iowrite1;>buffer.2.reset
#goto 
goto;>main--label
#label
zerosize;;help_ready_splash--label
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#prline
fopwri1;:T
fopwri1;:y
fopwri1;:p
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:?
fopwri1;:'
fopwri1;:\s
fopwri1;:f
fopwri1;:o
fopwri1;:r
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:\s
fopwri1;:R
fopwri1;:E
fopwri1;:A
fopwri1;:D
fopwri1;:Y
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;main--label
#Set text colors
dataread1;>*0+0---
iowrite1;>io.textcolor
#Dump (character)
dataread1;>drive
iowrite1;>io.ttywr
#print
fopwri1;::
fopwri1;:\b
fopwri1;:>
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#goto (extra code stores away return address.)
setreg1;>goto--jumper-41-2
s1push1
goto;>cp.getentry--label
zerosize;;goto--jumper-41-2
#print newline
fopwri1;:\n
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>validflg
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--45-1
null;;tabstrc--adrbuff--45-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--45-1
null;;tabstrc--outbuff--45-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--45-1

datawrite1;>tabstrc--recurs-tabbuff--45-1_1
dataread1;;tabstrc--recurs-tabbuff--45-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--45-1_1
dataread1;;tabstrc--recurs-tabbuff_read--45-1_1

setreg2;:?


gotoif;>tabstrc--recurs-checkyes--45-1_1
goto;>tabstrc--recurs-checkno--45-1_1
zerosize;;tabstrc--recurs-checkyes--45-1_1
##set flag########
setreg1;>tabstrc--outbuff--45-1
datawrite1;>tabstrc--recurs-flag--45-1_1
setreg1;+
datawrite1;;tabstrc--recurs-flag--45-1_1
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--45-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--45-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-45-3
goto;>goto--jumper-45-3
setreg1;>goto--jumper-45-3;goto--branch-45-3
s1push1
goto;>help--label
zerosize;;goto--jumper-45-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-45-4
goto;>goto--jumper-45-4
dataread1;>@1;goto--branch-45-4
datawrite1;>validflg
zerosize;;goto--jumper-45-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--46-1
null;;tabstrc--adrbuff--46-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--46-1
null;;tabstrc--outbuff--46-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--46-1

datawrite1;>tabstrc--recurs-tabbuff--46-1_1
dataread1;;tabstrc--recurs-tabbuff--46-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--46-1_1
dataread1;;tabstrc--recurs-tabbuff_read--46-1_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--46-1_1
goto;>tabstrc--recurs-checkno--46-1_1
zerosize;;tabstrc--recurs-checkyes--46-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--46-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--46-1

setreg1;>tabstrc--adrbuff--46-1

datawrite1;>tabstrc--recurs-tabbuff--46-1_2
dataread1;;tabstrc--recurs-tabbuff--46-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--46-1_2
dataread1;;tabstrc--recurs-tabbuff_read--46-1_2

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--46-1_2
goto;>tabstrc--recurs-checkno--46-1_2
zerosize;;tabstrc--recurs-checkyes--46-1_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--46-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--46-1

setreg1;>tabstrc--adrbuff--46-1

datawrite1;>tabstrc--recurs-tabbuff--46-1_3
dataread1;;tabstrc--recurs-tabbuff--46-1_3
datawrite1;>tabstrc--recurs-tabbuff_read--46-1_3
dataread1;;tabstrc--recurs-tabbuff_read--46-1_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--46-1_3
goto;>tabstrc--recurs-checkno--46-1_3
zerosize;;tabstrc--recurs-checkyes--46-1_3
##set flag########
setreg1;>tabstrc--outbuff--46-1
datawrite1;>tabstrc--recurs-flag--46-1_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--46-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--46-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--46-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--46-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--46-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-46-3
goto;>goto--jumper-46-3
setreg1;>goto--jumper-46-3;goto--branch-46-3
s1push1
goto;>vdi--label
zerosize;;goto--jumper-46-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-46-4
goto;>goto--jumper-46-4
dataread1;>@1;goto--branch-46-4
datawrite1;>validflg
zerosize;;goto--jumper-46-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--47-1
null;;tabstrc--adrbuff--47-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--47-1
null;;tabstrc--outbuff--47-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--47-1

datawrite1;>tabstrc--recurs-tabbuff--47-1_1
dataread1;;tabstrc--recurs-tabbuff--47-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--47-1_1
dataread1;;tabstrc--recurs-tabbuff_read--47-1_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--47-1_1
goto;>tabstrc--recurs-checkno--47-1_1
zerosize;;tabstrc--recurs-checkyes--47-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--47-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--47-1

setreg1;>tabstrc--adrbuff--47-1

datawrite1;>tabstrc--recurs-tabbuff--47-1_2
dataread1;;tabstrc--recurs-tabbuff--47-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--47-1_2
dataread1;;tabstrc--recurs-tabbuff_read--47-1_2

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--47-1_2
goto;>tabstrc--recurs-checkno--47-1_2
zerosize;;tabstrc--recurs-checkyes--47-1_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--47-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--47-1

setreg1;>tabstrc--adrbuff--47-1

datawrite1;>tabstrc--recurs-tabbuff--47-1_3
dataread1;;tabstrc--recurs-tabbuff--47-1_3
datawrite1;>tabstrc--recurs-tabbuff_read--47-1_3
dataread1;;tabstrc--recurs-tabbuff_read--47-1_3

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--47-1_3
goto;>tabstrc--recurs-checkno--47-1_3
zerosize;;tabstrc--recurs-checkyes--47-1_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--47-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--47-1

setreg1;>tabstrc--adrbuff--47-1

datawrite1;>tabstrc--recurs-tabbuff--47-1_4
dataread1;;tabstrc--recurs-tabbuff--47-1_4
datawrite1;>tabstrc--recurs-tabbuff_read--47-1_4
dataread1;;tabstrc--recurs-tabbuff_read--47-1_4

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--47-1_4
goto;>tabstrc--recurs-checkno--47-1_4
zerosize;;tabstrc--recurs-checkyes--47-1_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--47-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--47-1

setreg1;>tabstrc--adrbuff--47-1

datawrite1;>tabstrc--recurs-tabbuff--47-1_5
dataread1;;tabstrc--recurs-tabbuff--47-1_5
datawrite1;>tabstrc--recurs-tabbuff_read--47-1_5
dataread1;;tabstrc--recurs-tabbuff_read--47-1_5

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--47-1_5
goto;>tabstrc--recurs-checkno--47-1_5
zerosize;;tabstrc--recurs-checkyes--47-1_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--47-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--47-1

setreg1;>tabstrc--adrbuff--47-1

datawrite1;>tabstrc--recurs-tabbuff--47-1_6
dataread1;;tabstrc--recurs-tabbuff--47-1_6
datawrite1;>tabstrc--recurs-tabbuff_read--47-1_6
dataread1;;tabstrc--recurs-tabbuff_read--47-1_6

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--47-1_6
goto;>tabstrc--recurs-checkno--47-1_6
zerosize;;tabstrc--recurs-checkyes--47-1_6
##set flag########
setreg1;>tabstrc--outbuff--47-1
datawrite1;>tabstrc--recurs-flag--47-1_6
setreg1;+
datawrite1;;tabstrc--recurs-flag--47-1_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--47-1_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--47-1_5
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--47-1_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--47-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--47-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--47-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--47-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-47-3
goto;>goto--jumper-47-3
setreg1;>goto--jumper-47-3;goto--branch-47-3
s1push1
goto;>drives--label
zerosize;;goto--jumper-47-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-47-4
goto;>goto--jumper-47-4
dataread1;>@1;goto--branch-47-4
datawrite1;>validflg
zerosize;;goto--jumper-47-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--48-1
null;;tabstrc--adrbuff--48-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--48-1
null;;tabstrc--outbuff--48-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--48-1

datawrite1;>tabstrc--recurs-tabbuff--48-1_1
dataread1;;tabstrc--recurs-tabbuff--48-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--48-1_1
dataread1;;tabstrc--recurs-tabbuff_read--48-1_1

setreg2;:v


gotoif;>tabstrc--recurs-checkyes--48-1_1
goto;>tabstrc--recurs-checkno--48-1_1
zerosize;;tabstrc--recurs-checkyes--48-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--48-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--48-1

setreg1;>tabstrc--adrbuff--48-1

datawrite1;>tabstrc--recurs-tabbuff--48-1_2
dataread1;;tabstrc--recurs-tabbuff--48-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--48-1_2
dataread1;;tabstrc--recurs-tabbuff_read--48-1_2

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--48-1_2
goto;>tabstrc--recurs-checkno--48-1_2
zerosize;;tabstrc--recurs-checkyes--48-1_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--48-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--48-1

setreg1;>tabstrc--adrbuff--48-1

datawrite1;>tabstrc--recurs-tabbuff--48-1_3
dataread1;;tabstrc--recurs-tabbuff--48-1_3
datawrite1;>tabstrc--recurs-tabbuff_read--48-1_3
dataread1;;tabstrc--recurs-tabbuff_read--48-1_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--48-1_3
goto;>tabstrc--recurs-checkno--48-1_3
zerosize;;tabstrc--recurs-checkyes--48-1_3
##set flag########
setreg1;>tabstrc--outbuff--48-1
datawrite1;>tabstrc--recurs-flag--48-1_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--48-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--48-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--48-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--48-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--48-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-48-3
goto;>goto--jumper-48-3
setreg1;>goto--jumper-48-3;goto--branch-48-3
s1push1
goto;>version--label
zerosize;;goto--jumper-48-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-48-4
goto;>goto--jumper-48-4
dataread1;>@1;goto--branch-48-4
datawrite1;>validflg
zerosize;;goto--jumper-48-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--49-1
null;;tabstrc--adrbuff--49-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--49-1
null;;tabstrc--outbuff--49-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--49-1

datawrite1;>tabstrc--recurs-tabbuff--49-1_1
dataread1;;tabstrc--recurs-tabbuff--49-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--49-1_1
dataread1;;tabstrc--recurs-tabbuff_read--49-1_1

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--49-1_1
goto;>tabstrc--recurs-checkno--49-1_1
zerosize;;tabstrc--recurs-checkyes--49-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--49-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--49-1

setreg1;>tabstrc--adrbuff--49-1

datawrite1;>tabstrc--recurs-tabbuff--49-1_2
dataread1;;tabstrc--recurs-tabbuff--49-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--49-1_2
dataread1;;tabstrc--recurs-tabbuff_read--49-1_2

setreg2;:i


gotoif;>tabstrc--recurs-checkyes--49-1_2
goto;>tabstrc--recurs-checkno--49-1_2
zerosize;;tabstrc--recurs-checkyes--49-1_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--49-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--49-1

setreg1;>tabstrc--adrbuff--49-1

datawrite1;>tabstrc--recurs-tabbuff--49-1_3
dataread1;;tabstrc--recurs-tabbuff--49-1_3
datawrite1;>tabstrc--recurs-tabbuff_read--49-1_3
dataread1;;tabstrc--recurs-tabbuff_read--49-1_3

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--49-1_3
goto;>tabstrc--recurs-checkno--49-1_3
zerosize;;tabstrc--recurs-checkyes--49-1_3
##set flag########
setreg1;>tabstrc--outbuff--49-1
datawrite1;>tabstrc--recurs-flag--49-1_3
setreg1;+
datawrite1;;tabstrc--recurs-flag--49-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--49-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--49-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--49-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--49-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-49-3
goto;>goto--jumper-49-3
setreg1;>goto--jumper-49-3;goto--branch-49-3
s1push1
goto;>directory_list--label
zerosize;;goto--jumper-49-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-49-4
goto;>goto--jumper-49-4
dataread1;>@1;goto--branch-49-4
datawrite1;>validflg
zerosize;;goto--jumper-49-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--50-1
null;;tabstrc--adrbuff--50-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--50-1
null;;tabstrc--outbuff--50-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_1
dataread1;;tabstrc--recurs-tabbuff--50-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_1
dataread1;;tabstrc--recurs-tabbuff_read--50-1_1

setreg2;:s


gotoif;>tabstrc--recurs-checkyes--50-1_1
goto;>tabstrc--recurs-checkno--50-1_1
zerosize;;tabstrc--recurs-checkyes--50-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_2
dataread1;;tabstrc--recurs-tabbuff--50-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_2
dataread1;;tabstrc--recurs-tabbuff_read--50-1_2

setreg2;:h


gotoif;>tabstrc--recurs-checkyes--50-1_2
goto;>tabstrc--recurs-checkno--50-1_2
zerosize;;tabstrc--recurs-checkyes--50-1_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_3
dataread1;;tabstrc--recurs-tabbuff--50-1_3
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_3
dataread1;;tabstrc--recurs-tabbuff_read--50-1_3

setreg2;:u


gotoif;>tabstrc--recurs-checkyes--50-1_3
goto;>tabstrc--recurs-checkno--50-1_3
zerosize;;tabstrc--recurs-checkyes--50-1_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_4
dataread1;;tabstrc--recurs-tabbuff--50-1_4
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_4
dataread1;;tabstrc--recurs-tabbuff_read--50-1_4

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--50-1_4
goto;>tabstrc--recurs-checkno--50-1_4
zerosize;;tabstrc--recurs-checkyes--50-1_4
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_5
dataread1;;tabstrc--recurs-tabbuff--50-1_5
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_5
dataread1;;tabstrc--recurs-tabbuff_read--50-1_5

setreg2;:d


gotoif;>tabstrc--recurs-checkyes--50-1_5
goto;>tabstrc--recurs-checkno--50-1_5
zerosize;;tabstrc--recurs-checkyes--50-1_5
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_6
dataread1;;tabstrc--recurs-tabbuff--50-1_6
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_6
dataread1;;tabstrc--recurs-tabbuff_read--50-1_6

setreg2;:o


gotoif;>tabstrc--recurs-checkyes--50-1_6
goto;>tabstrc--recurs-checkno--50-1_6
zerosize;;tabstrc--recurs-checkyes--50-1_6
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_7
dataread1;;tabstrc--recurs-tabbuff--50-1_7
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_7
dataread1;;tabstrc--recurs-tabbuff_read--50-1_7

setreg2;:w


gotoif;>tabstrc--recurs-checkyes--50-1_7
goto;>tabstrc--recurs-checkno--50-1_7
zerosize;;tabstrc--recurs-checkyes--50-1_7
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--50-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--50-1

setreg1;>tabstrc--adrbuff--50-1

datawrite1;>tabstrc--recurs-tabbuff--50-1_8
dataread1;;tabstrc--recurs-tabbuff--50-1_8
datawrite1;>tabstrc--recurs-tabbuff_read--50-1_8
dataread1;;tabstrc--recurs-tabbuff_read--50-1_8

setreg2;:n


gotoif;>tabstrc--recurs-checkyes--50-1_8
goto;>tabstrc--recurs-checkno--50-1_8
zerosize;;tabstrc--recurs-checkyes--50-1_8
##set flag########
setreg1;>tabstrc--outbuff--50-1
datawrite1;>tabstrc--recurs-flag--50-1_8
setreg1;+
datawrite1;;tabstrc--recurs-flag--50-1_8
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_8
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_7
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_6
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_5
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--50-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--50-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-50-3
goto;>goto--jumper-50-3
setreg1;>goto--jumper-50-3;goto--branch-50-3
s1push1
goto;>shutdown--label
zerosize;;goto--jumper-50-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-50-4
goto;>goto--jumper-50-4
dataread1;>@1;goto--branch-50-4
datawrite1;>validflg
zerosize;;goto--jumper-50-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--55-1
null;;tabstrc--adrbuff--55-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--55-1
null;;tabstrc--outbuff--55-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--55-1

datawrite1;>tabstrc--recurs-tabbuff--55-1_1
dataread1;;tabstrc--recurs-tabbuff--55-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--55-1_1
dataread1;;tabstrc--recurs-tabbuff_read--55-1_1

setreg2;:a


gotoif;>tabstrc--recurs-checkyes--55-1_1
goto;>tabstrc--recurs-checkno--55-1_1
zerosize;;tabstrc--recurs-checkyes--55-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--55-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--55-1

setreg1;>tabstrc--adrbuff--55-1

datawrite1;>tabstrc--recurs-tabbuff--55-1_2
dataread1;;tabstrc--recurs-tabbuff--55-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--55-1_2
dataread1;;tabstrc--recurs-tabbuff_read--55-1_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--55-1_2
goto;>tabstrc--recurs-checkno--55-1_2
zerosize;;tabstrc--recurs-checkyes--55-1_2
##set flag########
setreg1;>tabstrc--outbuff--55-1
datawrite1;>tabstrc--recurs-flag--55-1_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--55-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--55-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--55-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--55-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-55-3
goto;>goto--jumper-55-3
setreg1;>goto--jumper-55-3;goto--branch-55-3
s1push1
goto;>driveA--label
zerosize;;goto--jumper-55-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-55-4
goto;>goto--jumper-55-4
dataread1;>@1;goto--branch-55-4
datawrite1;>validflg
zerosize;;goto--jumper-55-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--56-1
null;;tabstrc--adrbuff--56-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--56-1
null;;tabstrc--outbuff--56-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--56-1

datawrite1;>tabstrc--recurs-tabbuff--56-1_1
dataread1;;tabstrc--recurs-tabbuff--56-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--56-1_1
dataread1;;tabstrc--recurs-tabbuff_read--56-1_1

setreg2;:A


gotoif;>tabstrc--recurs-checkyes--56-1_1
goto;>tabstrc--recurs-checkno--56-1_1
zerosize;;tabstrc--recurs-checkyes--56-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--56-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--56-1

setreg1;>tabstrc--adrbuff--56-1

datawrite1;>tabstrc--recurs-tabbuff--56-1_2
dataread1;;tabstrc--recurs-tabbuff--56-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--56-1_2
dataread1;;tabstrc--recurs-tabbuff_read--56-1_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--56-1_2
goto;>tabstrc--recurs-checkno--56-1_2
zerosize;;tabstrc--recurs-checkyes--56-1_2
##set flag########
setreg1;>tabstrc--outbuff--56-1
datawrite1;>tabstrc--recurs-flag--56-1_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--56-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--56-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--56-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--56-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-56-3
goto;>goto--jumper-56-3
setreg1;>goto--jumper-56-3;goto--branch-56-3
s1push1
goto;>driveA--label
zerosize;;goto--jumper-56-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-56-4
goto;>goto--jumper-56-4
dataread1;>@1;goto--branch-56-4
datawrite1;>validflg
zerosize;;goto--jumper-56-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--58-1
null;;tabstrc--adrbuff--58-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--58-1
null;;tabstrc--outbuff--58-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--58-1

datawrite1;>tabstrc--recurs-tabbuff--58-1_1
dataread1;;tabstrc--recurs-tabbuff--58-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--58-1_1
dataread1;;tabstrc--recurs-tabbuff_read--58-1_1

setreg2;:b


gotoif;>tabstrc--recurs-checkyes--58-1_1
goto;>tabstrc--recurs-checkno--58-1_1
zerosize;;tabstrc--recurs-checkyes--58-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--58-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--58-1

setreg1;>tabstrc--adrbuff--58-1

datawrite1;>tabstrc--recurs-tabbuff--58-1_2
dataread1;;tabstrc--recurs-tabbuff--58-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--58-1_2
dataread1;;tabstrc--recurs-tabbuff_read--58-1_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--58-1_2
goto;>tabstrc--recurs-checkno--58-1_2
zerosize;;tabstrc--recurs-checkyes--58-1_2
##set flag########
setreg1;>tabstrc--outbuff--58-1
datawrite1;>tabstrc--recurs-flag--58-1_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--58-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--58-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--58-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--58-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-58-3
goto;>goto--jumper-58-3
setreg1;>goto--jumper-58-3;goto--branch-58-3
s1push1
goto;>driveB--label
zerosize;;goto--jumper-58-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-58-4
goto;>goto--jumper-58-4
dataread1;>@1;goto--branch-58-4
datawrite1;>validflg
zerosize;;goto--jumper-58-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--59-1
null;;tabstrc--adrbuff--59-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--59-1
null;;tabstrc--outbuff--59-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--59-1

datawrite1;>tabstrc--recurs-tabbuff--59-1_1
dataread1;;tabstrc--recurs-tabbuff--59-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--59-1_1
dataread1;;tabstrc--recurs-tabbuff_read--59-1_1

setreg2;:B


gotoif;>tabstrc--recurs-checkyes--59-1_1
goto;>tabstrc--recurs-checkno--59-1_1
zerosize;;tabstrc--recurs-checkyes--59-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--59-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--59-1

setreg1;>tabstrc--adrbuff--59-1

datawrite1;>tabstrc--recurs-tabbuff--59-1_2
dataread1;;tabstrc--recurs-tabbuff--59-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--59-1_2
dataread1;;tabstrc--recurs-tabbuff_read--59-1_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--59-1_2
goto;>tabstrc--recurs-checkno--59-1_2
zerosize;;tabstrc--recurs-checkyes--59-1_2
##set flag########
setreg1;>tabstrc--outbuff--59-1
datawrite1;>tabstrc--recurs-flag--59-1_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--59-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--59-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--59-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--59-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-59-3
goto;>goto--jumper-59-3
setreg1;>goto--jumper-59-3;goto--branch-59-3
s1push1
goto;>driveB--label
zerosize;;goto--jumper-59-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-59-4
goto;>goto--jumper-59-4
dataread1;>@1;goto--branch-59-4
datawrite1;>validflg
zerosize;;goto--jumper-59-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--61-1
null;;tabstrc--adrbuff--61-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--61-1
null;;tabstrc--outbuff--61-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--61-1

datawrite1;>tabstrc--recurs-tabbuff--61-1_1
dataread1;;tabstrc--recurs-tabbuff--61-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--61-1_1
dataread1;;tabstrc--recurs-tabbuff_read--61-1_1

setreg2;:r


gotoif;>tabstrc--recurs-checkyes--61-1_1
goto;>tabstrc--recurs-checkno--61-1_1
zerosize;;tabstrc--recurs-checkyes--61-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--61-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--61-1

setreg1;>tabstrc--adrbuff--61-1

datawrite1;>tabstrc--recurs-tabbuff--61-1_2
dataread1;;tabstrc--recurs-tabbuff--61-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--61-1_2
dataread1;;tabstrc--recurs-tabbuff_read--61-1_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--61-1_2
goto;>tabstrc--recurs-checkno--61-1_2
zerosize;;tabstrc--recurs-checkyes--61-1_2
##set flag########
setreg1;>tabstrc--outbuff--61-1
datawrite1;>tabstrc--recurs-flag--61-1_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--61-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--61-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--61-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--61-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-61-3
goto;>goto--jumper-61-3
setreg1;>goto--jumper-61-3;goto--branch-61-3
s1push1
goto;>driveR--label
zerosize;;goto--jumper-61-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-61-4
goto;>goto--jumper-61-4
dataread1;>@1;goto--branch-61-4
datawrite1;>validflg
zerosize;;goto--jumper-61-4
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>@0
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--62-1
null;;tabstrc--adrbuff--62-1
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--62-1
null;;tabstrc--outbuff--62-1
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--62-1

datawrite1;>tabstrc--recurs-tabbuff--62-1_1
dataread1;;tabstrc--recurs-tabbuff--62-1_1
datawrite1;>tabstrc--recurs-tabbuff_read--62-1_1
dataread1;;tabstrc--recurs-tabbuff_read--62-1_1

setreg2;:R


gotoif;>tabstrc--recurs-checkyes--62-1_1
goto;>tabstrc--recurs-checkno--62-1_1
zerosize;;tabstrc--recurs-checkyes--62-1_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--62-1
setreg2;+
add
datawrite1;>tabstrc--adrbuff--62-1

setreg1;>tabstrc--adrbuff--62-1

datawrite1;>tabstrc--recurs-tabbuff--62-1_2
dataread1;;tabstrc--recurs-tabbuff--62-1_2
datawrite1;>tabstrc--recurs-tabbuff_read--62-1_2
dataread1;;tabstrc--recurs-tabbuff_read--62-1_2

setreg2;::


gotoif;>tabstrc--recurs-checkyes--62-1_2
goto;>tabstrc--recurs-checkno--62-1_2
zerosize;;tabstrc--recurs-checkyes--62-1_2
##set flag########
setreg1;>tabstrc--outbuff--62-1
datawrite1;>tabstrc--recurs-flag--62-1_2
setreg1;+
datawrite1;;tabstrc--recurs-flag--62-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--62-1_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--62-1_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--62-1
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>cmdflg
#conditional subroutine goto
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-62-3
goto;>goto--jumper-62-3
setreg1;>goto--jumper-62-3;goto--branch-62-3
s1push1
goto;>driveR--label
zerosize;;goto--jumper-62-3
#conditional set
dataread1;>cmdflg
dataread2;>@1
gotoif;>goto--branch-62-4
goto;>goto--jumper-62-4
dataread1;>@1;goto--branch-62-4
datawrite1;>validflg
zerosize;;goto--jumper-62-4
#conditional subroutine goto
dataread1;>validflg
dataread2;>@0
gotoif;>goto--branch-64-0
goto;>goto--jumper-64-0
setreg1;>goto--jumper-64-0;goto--branch-64-0
s1push1
goto;>invalid--label
zerosize;;goto--jumper-64-0
#goto 
goto;>main--label
#label
zerosize;;driveA--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-71-0
goto;>goto--jumper-71-0
setreg1;>goto--jumper-71-0;goto--branch-71-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-71-0
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-73-1
goto;>goto--branch-73-1
goto;>flow--con-x-1;goto--branch-73-1

zerosize;;goto--jumper-73-1
zerosize;;flow--con-x-1--start
#val (used with set to change variable value during runtime.)
setreg1;:A
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-1
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-77-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-77-0
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-78-0;uiter-loopback-78-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-78-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-78-0
gotoif;>uiter-loopback-78-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-79-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-79-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-82-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-82-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;driveB--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-90-0
goto;>goto--jumper-90-0
setreg1;>goto--jumper-90-0;goto--branch-90-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-90-0
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-92-1
goto;>goto--branch-92-1
goto;>flow--con-x-2;goto--branch-92-1

zerosize;;goto--jumper-92-1
zerosize;;flow--con-x-2--start
#val (used with set to change variable value during runtime.)
setreg1;:B
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-2
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-96-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-96-0
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-97-0;uiter-loopback-97-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-97-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-97-0
gotoif;>uiter-loopback-97-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-98-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-98-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-101-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-101-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;driveR--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-109-0
goto;>goto--jumper-109-0
setreg1;>goto--jumper-109-0;goto--branch-109-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-109-0
#conditional flow control begin
dataread1;>cp.size
dataread2;>@3
gotoifless;>goto--jumper-111-1
goto;>goto--branch-111-1
goto;>flow--con-x-3;goto--branch-111-1

zerosize;;goto--jumper-111-1
zerosize;;flow--con-x-3--start
#val (used with set to change variable value during runtime.)
setreg1;:R
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>drive
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-3
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-116-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-116-0
#Upward range iterator
dataread1;>@3
datawrite1;>run_iter
setreg1;>uiter-retpos-117-0;uiter-loopback-117-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-117-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-117-0
gotoif;>uiter-loopback-117-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-118-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-118-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-121-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-121-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list--label
#conditional subroutine goto
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-128-0
goto;>goto--jumper-128-0
setreg1;>goto--jumper-128-0;goto--branch-128-0
s1push1
goto;>directory_list_R--label
zerosize;;goto--jumper-128-0
#conditional subroutine goto
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-129-0
goto;>goto--jumper-129-0
setreg1;>goto--jumper-129-0;goto--branch-129-0
s1push1
goto;>directory_list_B--label
zerosize;;goto--jumper-129-0
#conditional subroutine goto
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-130-0
goto;>goto--jumper-130-0
setreg1;>goto--jumper-130-0;goto--branch-130-0
s1push1
goto;>directory_list_A--label
zerosize;;goto--jumper-130-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_A--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:A
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-135-0;uiter-loopback-135-0
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-135-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-135-0
gotoif;>uiter-loopback-135-0

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:0
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-138-0;uiter-loopback-138-0
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-138-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-138-0
gotoif;>uiter-loopback-138-0

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-140-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-140-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_B--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:B
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-145-0;uiter-loopback-145-0
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-145-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-145-0
gotoif;>uiter-loopback-145-0

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-148-0;uiter-loopback-148-0
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-148-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-148-0
gotoif;>uiter-loopback-148-0

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-150-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-150-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;directory_list_R--label
#print
fopwri1;:F
fopwri1;:i
fopwri1;:l
fopwri1;:e
fopwri1;:s
fopwri1;:\s
fopwri1;:o
fopwri1;:n
fopwri1;:\s
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:\s
fopwri1;:\v
fopwri1;:\s
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-155-0;uiter-loopback-155-0
s1push1
goto;>pattern_print_char--label
dataread1;>run_iter;uiter-retpos-155-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-155-0
gotoif;>uiter-loopback-155-0

#print newline
fopwri1;:\n
#vdin
fopset1;>vdi.cli.in
fopwri1;:l
fopwri1;:i
fopwri1;:s
fopwri1;:t
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopset1;>io.ttywr
#Upward range iterator
dataread1;>@4
datawrite1;>run_iter
setreg1;>uiter-retpos-158-0;uiter-loopback-158-0
s1push1
goto;>run_send_char--label
dataread1;>run_iter;uiter-retpos-158-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-158-0
gotoif;>uiter-loopback-158-0

#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-160-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-160-0
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;invalid--label
#val (used with set to change variable value during runtime.)
setreg1;0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#conditional subroutine goto
dataread1;>cp.size
dataread2;>@4
gotoifmore;>goto--branch-167-0
goto;>goto--jumper-167-0
setreg1;>goto--jumper-167-0;goto--branch-167-0
s1push1
goto;>extcheck--label
zerosize;;goto--jumper-167-0
#Set text colors
dataread1;>*++0---
iowrite1;>io.textcolor
#conditional flow control begin
dataread1;>cp.size
dataread2;>@2
gotoifless;>goto--branch-170-0
goto;>goto--jumper-170-0
goto;>flow--con-x-4;goto--branch-170-0

zerosize;;goto--jumper-170-0
zerosize;;flow--con-x-4--start
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>@1
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--173-0
dataread1;;tabr--adrbuff--173-0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>invalid_charcheck
#conditional flow control begin
dataread1;>invalid_charcheck
dataread2;>::
gotoif;>goto--jumper-175-0
goto;>goto--branch-175-0
goto;>flow--con-x-5;goto--branch-175-0

zerosize;;goto--jumper-175-0
zerosize;;flow--con-x-5--start
#prline
fopwri1;:D
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:\s
fopwri1;:N
fopwri1;:o
fopwri1;:t
fopwri1;:\s
fopwri1;:V
fopwri1;:a
fopwri1;:l
fopwri1;:i
fopwri1;:d
fopwri1;:.
fopwri1;:\s
fopwri1;:s
fopwri1;:e
fopwri1;:e
fopwri1;:\s
fopwri1;:'
fopwri1;:d
fopwri1;:r
fopwri1;:i
fopwri1;:v
fopwri1;:e
fopwri1;:s
fopwri1;:'
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-5
zerosize;;flow--con-x-4
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopset1;>io.ttywr
#conditional set
dataread1;>drive
dataread2;>:A
gotoif;>goto--branch-183-0
goto;>goto--jumper-183-0
dataread1;>:0;goto--branch-183-0
datawrite1;>driveref
zerosize;;goto--jumper-183-0
#conditional set
dataread1;>drive
dataread2;>:B
gotoif;>goto--branch-184-0
goto;>goto--jumper-184-0
dataread1;>:1;goto--branch-184-0
datawrite1;>driveref
zerosize;;goto--jumper-184-0
#conditional set
dataread1;>drive
dataread2;>:R
gotoif;>goto--branch-185-0
goto;>goto--jumper-185-0
dataread1;>:2;goto--branch-185-0
datawrite1;>driveref
zerosize;;goto--jumper-185-0
#get(1) (may be used with set, or asm code)
dataread1;>driveref
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #187-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '187-0' 
#vdin
fopset1;>vdi.cli.in
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-189-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-189-0
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-190-0;uiter-loopback-190-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-190-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-190-0
gotoif;>uiter-loopback-190-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-191-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-191-0
#vdin
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopset1;>io.ttywr
#goto (extra code stores away return address.)
setreg1;>goto--jumper-195-0
s1push1
goto;>run_send_setup--label
zerosize;;goto--jumper-195-0
#Upward range iterator
dataread1;>@0
datawrite1;>run_iter
setreg1;>uiter-retpos-196-0;uiter-loopback-196-0
s1push1
goto;>run_send_char_exec--label
dataread1;>run_iter;uiter-retpos-196-0
setreg2;10x1
add
datawrite1;>run_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-196-0
gotoif;>uiter-loopback-196-0

#goto (extra code stores away return address.)
setreg1;>goto--jumper-197-0
s1push1
goto;>cmd_run_send_newline--label
zerosize;;goto--jumper-197-0
#goto (extra code stores away return address.)
setreg1;>goto--jumper-199-0
s1push1
goto;>vdi_outloop--label
zerosize;;goto--jumper-199-0
#buffer 2 reset
iowrite1;>buffer.2.reset
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;extcheck--label
#return from subroutine.
s1pop1
gotoreg1
#subtract (2op math)
dataread1;>cp.size
dataread2;>@4
sub
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extoffset
#######tabstrc
#init
setreg1;10x85
dataread2;>@0
mul
dataread2;>extoffset
add
adddata1;>cp.buffer--table
datawrite1;>tabstrc--adrbuff--212-0
null;;tabstrc--adrbuff--212-0
#reset output buffer to 0
setreg1;0
datawrite1;>tabstrc--outbuff--212-0
null;;tabstrc--outbuff--212-0
#recursive_parser
#recursion

setreg1;>tabstrc--adrbuff--212-0

datawrite1;>tabstrc--recurs-tabbuff--212-0_1
dataread1;;tabstrc--recurs-tabbuff--212-0_1
datawrite1;>tabstrc--recurs-tabbuff_read--212-0_1
dataread1;;tabstrc--recurs-tabbuff_read--212-0_1

setreg2;:.


gotoif;>tabstrc--recurs-checkyes--212-0_1
goto;>tabstrc--recurs-checkno--212-0_1
zerosize;;tabstrc--recurs-checkyes--212-0_1
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--212-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--212-0

setreg1;>tabstrc--adrbuff--212-0

datawrite1;>tabstrc--recurs-tabbuff--212-0_2
dataread1;;tabstrc--recurs-tabbuff--212-0_2
datawrite1;>tabstrc--recurs-tabbuff_read--212-0_2
dataread1;;tabstrc--recurs-tabbuff_read--212-0_2

setreg2;:t


gotoif;>tabstrc--recurs-checkyes--212-0_2
goto;>tabstrc--recurs-checkno--212-0_2
zerosize;;tabstrc--recurs-checkyes--212-0_2
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--212-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--212-0

setreg1;>tabstrc--adrbuff--212-0

datawrite1;>tabstrc--recurs-tabbuff--212-0_3
dataread1;;tabstrc--recurs-tabbuff--212-0_3
datawrite1;>tabstrc--recurs-tabbuff_read--212-0_3
dataread1;;tabstrc--recurs-tabbuff_read--212-0_3

setreg2;:x


gotoif;>tabstrc--recurs-checkyes--212-0_3
goto;>tabstrc--recurs-checkno--212-0_3
zerosize;;tabstrc--recurs-checkyes--212-0_3
#recursion
#increment pointer
dataread1;>tabstrc--adrbuff--212-0
setreg2;+
add
datawrite1;>tabstrc--adrbuff--212-0

setreg1;>tabstrc--adrbuff--212-0

datawrite1;>tabstrc--recurs-tabbuff--212-0_4
dataread1;;tabstrc--recurs-tabbuff--212-0_4
datawrite1;>tabstrc--recurs-tabbuff_read--212-0_4
dataread1;;tabstrc--recurs-tabbuff_read--212-0_4

setreg2;:e


gotoif;>tabstrc--recurs-checkyes--212-0_4
goto;>tabstrc--recurs-checkno--212-0_4
zerosize;;tabstrc--recurs-checkyes--212-0_4
##set flag########
setreg1;>tabstrc--outbuff--212-0
datawrite1;>tabstrc--recurs-flag--212-0_4
setreg1;+
datawrite1;;tabstrc--recurs-flag--212-0_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--212-0_4
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--212-0_3
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--212-0_2
#recursionskip endpoint
zerosize;;tabstrc--recurs-checkno--212-0_1
#read output to register 1 for 'set' to use.
dataread1;>tabstrc--outbuff--212-0
#######tabstrc END
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>extflg
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;cmd_run_send_newline--label
#conditional flow control begin
dataread1;>extflg
dataread2;>$false
gotoif;>goto--jumper-219-1
goto;>goto--branch-219-1
goto;>flow--con-x-6;goto--branch-219-1

zerosize;;goto--jumper-219-1
zerosize;;flow--con-x-6--start
#vdi
fopset1;>vdi.cli.in
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-6
#vdi
fopset1;>vdi.cli.in
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_setup--label
#val (used with set to change variable value during runtime.)
setreg1;10x0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_char_exec--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--233-0
dataread1;;tabr--adrbuff--233-0
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_s_tmp
#conditional flow control begin
dataread1;>run_tobuffer_flg
dataread2;>@0
gotoif;>goto--jumper-235-0
goto;>goto--branch-235-0
goto;>flow--con-x-7;goto--branch-235-0

zerosize;;goto--jumper-235-0
zerosize;;flow--con-x-7--start
#conditional flow control begin
dataread1;>run_s_tmp
dataread2;>:\s
gotoif;>goto--jumper-236-1
goto;>goto--branch-236-1
goto;>flow--con-x-8;goto--branch-236-1

zerosize;;goto--jumper-236-1
zerosize;;flow--con-x-8--start
#val (used with set to change variable value during runtime.)
setreg1;10x1
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>run_tobuffer_flg
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-8
#get(1) (may be used with set, or asm code)
dataread1;>run_s_tmp
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #238-2
iowrite1;>vdi.cli.in#SSTNPL Source Line: '238-2' 
#return from subroutine.
s1pop1
gotoreg1
zerosize;;flow--con-x-7
#buffer 2 head write
dataread1;>run_s_tmp
iowrite1;>buffer.2.write.head
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;run_send_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--246-1
dataread1;;tabr--adrbuff--246-1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #246-2
iowrite1;>vdi.cli.in#SSTNPL Source Line: '246-2' 
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;pattern_print_char--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>run_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--250-0
dataread1;;tabr--adrbuff--250-0
iowrite1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;version--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-254-0
s1push1
goto;>splash--label
zerosize;;goto--jumper-254-0
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#prline
fopwri1;:\s
fopwri1;:C
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:\s
fopwri1;:I
fopwri1;:n
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:p
fopwri1;:r
fopwri1;:e
fopwri1;:t
fopwri1;:e
fopwri1;:r
fopwri1;:\s
fopwri1;:v
fopwri1;:2
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;vdi--label
#val (used with set to change variable value during runtime.)
setreg1;10x1
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #262-2
iowrite1;>vdi.cli.status#SSTNPL Source Line: '262-2' 
#Upward range iterator
dataread1;>@4
datawrite1;>vdi_iter
setreg1;>uiter-retpos-265-0;uiter-loopback-265-0
s1push1
goto;>vdi_buffiter--label
dataread1;>vdi_iter;uiter-retpos-265-0
setreg2;10x1
add
datawrite1;>vdi_iter
dataread2;>cp.itersize
gotoifless;>uiter-loopback-265-0
gotoif;>uiter-loopback-265-0

#val (used with set to change variable value during runtime.)
setreg1;:\n
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #266-2
iowrite1;>vdi.cli.in#SSTNPL Source Line: '266-2' 
#goto 
goto;>vdi_outloop--label
#label
zerosize;;vdi_outloop--label
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #273-0
ioread1;>vdi.cli.out#SSTNPL Source Line: '273-0' 
#set(1) (used after 2-op math, asm code, or get)
datawrite1;>vdi_vdioutput_buffer
#conditional return
dataread1;>vdi_vdioutput_buffer
dataread2;>@0
gotoif;>goto--branch-276-0
goto;>goto--jumper-276-0
s1pop1;;goto--branch-276-0
gotoreg1
zerosize;;goto--jumper-276-0
#Dump (character)
dataread1;>vdi_vdioutput_buffer
iowrite1;>io.ttywr
#goto 
goto;>vdi_outloop--label
#label
zerosize;;drives--label
#prline
fopwri1;:A
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:B
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:(
fopwri1;:T
fopwri1;:D
fopwri1;:S
fopwri1;:K
fopwri1;:1
fopwri1;:)
fopwri1;:\s
fopwri1;:f
fopwri1;:l
fopwri1;:o
fopwri1;:p
fopwri1;:p
fopwri1;:y
fopwri1;:\n
#prline
fopwri1;:R
fopwri1;::
fopwri1;:\s
fopwri1;:9
fopwri1;:.
fopwri1;:5
fopwri1;:M
fopwri1;:N
fopwri1;:\s
fopwri1;:H
fopwri1;:a
fopwri1;:r
fopwri1;:d
fopwri1;:w
fopwri1;:a
fopwri1;:r
fopwri1;:e
fopwri1;:\s
fopwri1;:R
fopwri1;:a
fopwri1;:m
fopwri1;:d
fopwri1;:i
fopwri1;:s
fopwri1;:k
fopwri1;:\n
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;vdi_buffiter--label
#SSTNPL table read instruction.
setreg1;10x85
dataread2;>@0
mul
dataread2;>vdi_iter
add
adddata1;>cp.buffer--table
datawrite1;>tabr--adrbuff--289-0
dataread1;;tabr--adrbuff--289-0
#___RAW ASSEMBLY CODE___
#_______NOTE: this corresponds to SSTNPL source line #290-0
iowrite1;>vdi.cli.in#SSTNPL Source Line: '290-0' 
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;help--label
#vdi
fopset1;>vdi.cli.in
fopwri1;:m
fopwri1;:e
fopwri1;:m
fopwri1;:b
fopwri1;:a
fopwri1;:k
fopwri1;:\s
fopwri1;:2
fopwri1;:\s
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopwri1;:.
fopwri1;:s
fopwri1;:t
fopwri1;:a
fopwri1;:t
fopwri1;:e
fopwri1;:.
fopwri1;:t
fopwri1;:r
fopwri1;:i
fopwri1;:\n
fopset1;>io.ttywr
#bprinthead2n
fopset1;>buffer.2.write.head
fopwri1;:c
fopwri1;:o
fopwri1;:m
fopwri1;:m
fopwri1;:a
fopwri1;:n
fopwri1;:d
fopset1;>io.ttywr
#vdi
fopset1;>vdi.cli.in
fopwri1;:r
fopwri1;:s
fopwri1;:t
fopwri1;:l
fopwri1;:d
fopwri1;:\s
fopwri1;:-
fopwri1;:1
fopwri1;:\s
fopwri1;:h
fopwri1;:e
fopwri1;:l
fopwri1;:p
fopwri1;:.
fopwri1;:t
fopwri1;:x
fopwri1;:e
fopwri1;:\n
fopset1;>io.ttywr
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;splash--label
#Set text colors
dataread1;>*+++0--
iowrite1;>io.textcolor
#print
fopwri1;:S
#Set text colors
dataread1;>*+++00-
iowrite1;>io.textcolor
#print
fopwri1;:B
#Set text colors
dataread1;>*+++-0-
iowrite1;>io.textcolor
#print
fopwri1;:T
#Set text colors
dataread1;>*+++-00
iowrite1;>io.textcolor
#print
fopwri1;:C
#Set text colors
dataread1;>*+++--0
iowrite1;>io.textcolor
#print
fopwri1;:V
#Set text colors
dataread1;>*+++0-0
iowrite1;>io.textcolor
#print
fopwri1;:M
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#print
fopwri1;:-
#Set text colors
dataread1;>*0++---
iowrite1;>io.textcolor
#print
fopwri1;:D
fopwri1;:O
fopwri1;:S
#Set text colors
dataread1;>*+++---
iowrite1;>io.textcolor
#return from subroutine.
s1pop1
gotoreg1
#label
zerosize;;shutdown--label
#goto (extra code stores away return address.)
setreg1;>goto--jumper-318-0
s1push1
goto;>splash--label
zerosize;;goto--jumper-318-0
#prline
fopwri1;:\s
fopwri1;:i
fopwri1;:s
fopwri1;:\s
fopwri1;:s
fopwri1;:h
fopwri1;:u
fopwri1;:t
fopwri1;:t
fopwri1;:i
fopwri1;:n
fopwri1;:g
fopwri1;:\s
fopwri1;:d
fopwri1;:o
fopwri1;:w
fopwri1;:n
fopwri1;:.
fopwri1;:.
fopwri1;:.
fopwri1;:\n
#prline
fopwri1;:d
fopwri1;:o
fopwri1;:n
fopwri1;:e
fopwri1;:.
fopwri1;:\n
#stop (shutdown vm)
stop
#module include: line 326-0: comprompt as cp
includeas;comprompt,cp
#END OF FILE
